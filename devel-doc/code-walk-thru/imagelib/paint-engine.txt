
Paint Engine


Normally programs are run on a local computer.  However, the X11 protocol
permits program logic to be executed on a remote computer (the network
server, misleading known as the graphics client) and displayed on the local
computer (the network client, misleading known as the graphics server).
For the purposes of this document, when we say server, we mean graphics
server and when we say client, we mean graphics client.  These are the
opposite meanings to the network version of these terms.

While this separation seems rather silly and not often used, this actually
makes us think a bit harder about the separation between the graphics card,
graphics memory, GPU & monitor (graphics server) and main memory and the
CPU (graphics client).

In the case that the program is executed locally, the hardware bus
separates the client and server.  This is far slower than main and graphics
memory and so shifting data between the client and server must be
minimised.

If the program is executed remotely, a network of much higher latency could
separate the client and server and so this becomes paramount.

A color model is a way of representing a subset of all possible
human-visible colors e.g. Indexed RGB, RGB, RGBA, CMYK and XYZ.  Any color
model can be represented in a device-independent format (i.e. at full
quality) on the client in main memory.  The graphics memory on the server
supports a limited number of color models (at least RGB) at the current
display depth.  Furthermore, this depth could be 8-bit or even 1-bit so
could be very low quality.  This means that unless the server can support
the document's color model, we must not store the document in graphics
memory.  Worse still, some servers such as VNC servers, seem to
corrupt/approximate graphics memory so even with a color model match, we
can still lose document information.

TODO: more on indexed vs truecolor

Therefore, we must store document data in main memory.  Every time we
change the document we must move it from main memory (client) to graphics
memory (server).  We cannot do separate drawing operations on main memory
and graphics memory as there is no guarantee that, for instance, the
graphics card will draw lines in graphics memory, the same way we draw in
main memory.  This is slow because it crosses the bus or the network.

However, if you are certain of the way the server stores image data, you
can store images of arbitrary depth if you encoded them cleverly.  For
example, if the graphics memory only supports 8-bit channels, you can still
store 16-bit channels by using pairs of pixels to represent single document
pixels.  This makes sense for something like OpenGL because you can then
then program the highly parallel shader hardware to perform arbitrary
transformations very rapidly.  This is hundreds or thousands of times
faster than the CPU and also avoids the bus crossing.  A complication is
that shader access usually requires binary graphics drivers, which many
distributions do not ship by default because they are “non-free”.

The graphics card almost certainly supports limited color space conversion
(e.g. 32-bit RGBA to 16-bit RGBA), zooming and rotation, and performs these
near instantly.  We should almost certainly use these capabilities instead
of burdening the CPU which performs these operations hundreds or thousands
of times slower.  A popular and portable interface to this hardware is
OpenGL.  Qt does not provide such an interfaces and performs all this in
software resulting in abysmal performance.  [TODO: this may have changed
with Qt4 since it has an OpenGL drawing buffer so might do the hardware
color space conversion for instance (e.g. Qpainter::drawImage(QImage,...)
might not call the software QPixmap::convertToImage() anymore)]  However,
if you must use the CPU, SIMD assembler instructions (MMX, SSE, SSE2 etc.)
can be used for performance.

In the beginning, KolourPaint used Qt3 without this hardware acceleration.
Storing the document in main memory (QImage) and converting it to the
format for graphics memory (QPixmap) using the software
QPixmap::convertToImage() was – and still is – too slow (from memory, about
100ms to convert a 1024x768x32 image for display on a screen with a
matching color model on a Celeron 2.2 Ghz!).

Therefore, for acceptable performance, KolourPaint stored the document
directly in graphics memory (QPixmap).

Therefore any document that does not match the screen's color model is
corrupted.  Actually, it's worse than that because we also convert all
indexed images to truecolor RGB (except on an indexed 8-bit).

Worse still, QPainter's behavior on QPixmap's changed from Qt3 to Qt4 and
whether or not XRENDER is supported by the display.

We must change this to stop corrupting the user's data.
We need a graphics library that can modify images in arbitrary color models
(to at least support RGBA and indexed RGBA color models) stored in main
memory.  We cannot use Krita's code as that is GPL.

We can then use OpenGL for hardware accelerated color space conversion.

TODO: describe stop gap Qt4 QPixmap solution without alpha channel.  Look
at svn log and blog and imagelib/kppainter.h comments.










        // QPixmap::mask() is hideously slow, and always returns a non-null
        // mask, if the pixmap has an alpha channel (even if the channel is
        // supposed to be empty).
        // QPixmap::hasAlpha() always returns
        // true purely because the depth is 32.

        // QPixmap::hasAlphaChannel() returns
        // true purely because the depth is 32.


        // Without an alpha channel, QPixmap::mask() will be fast and, if
there is no mask,
        // it will correctly return a null bitmap.
        // Note: QPixmap::mask() is slightly slow even on a pixmap without
an
        //       alpha channel.


        // Without XRENDER, pixmaps definitely don't have alpha channels.




pixmaps are the same depth as the screen (e.g. 32-bit) by default.
kpDocumentSaveOptions keeps the intended saving depth of the image (set by
kpDocument_Open.cpp).
