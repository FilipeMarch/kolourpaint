
commands/ Package


Commands wrap changes to a document, to make them undoable and redoable.
These classes are an implementation of the Command Design Pattern.

TODO: Many command classes are quite similar, so in the future, we might
      merge some of the classes e.g. kpToolPolygonalCommand and
      kpToolRectangularCommand.


1. Introduction

2. Foundation Classes
2.1. Interactions
2.2. External Interface
2.3. Internals

3. Derived Classes
3.1. commands/imagelib/
3.1.1. commands/imagelib/effects/
3.1.2. commands/imagelib/transforms/
3.2. commands/tools/
3.2.1. commands/tools/flow/
3.2.2. commands/tools/polygonal/
3.2.3. commands/tools/rectangular/
3.2.4. commands/tools/selection/

4. Effects of the Linear Command History


1. Introduction
~~~~~~~~~~~~~~~

Changes must not be made to the document directly using the document class.
You must encapsulate each change in a kpCommand so that it is undoable and
redoable.  Failure to do this results in inconsistent behaviour when
undoing and redoing.


2. Foundation Classes
~~~~~~~~~~~~~~~~~~~~~

These classes are a clone of the KDE KCommand hierarchy with extra features:


[>>>] kpCommandSize

Static methods that estimate the sizes of objects in bytes.

This is used by the command history to trim stored commands, once a
certain amount of memory is used by those commands.

kpCommandSize::SizeType is a large integer typedef for commands sizes,
which is not expected to overlow.


[>>>] kpCommand

Abstract base class for all commands.

size() must be implemented to return the estimated size of all fields in
the command, in bytes.  kpCommandSize methods can help here.

execute() must be implemented to run a command for the first time and also
to redo.

unexecute() must be implemented for undo.

kpCommand is similar to KCommand, except for the size() method.


[>>>] kpMacroCommand

kpMacroCommand is similar to KMacroCommand, except for the size() method.


[>>>] kpNamedCommand

Abstract convenience base class for commands.

This is the same as kpCommand except that name() is implemented to return
the name passed to the constructor.


[>>>} kpCommandHistoryBase

Clone of KCommandHistory with features required by KolourPaint but which
could also be useful for other apps:

  * Methods for peeking the undo/redo history

  * Undo/Redo history limited by both number and size (in bytes) of stored
    commands


[>>>] kpCommandHistory

KolourPaint-specific command history functionality -- subclass of
kpCommandHistoryBase.

Of special note is addCreateSelectionCommand(), which should be used when
adding kpToolSelectionCreateCommand's (see the layers/ documentation),
instead of addCommand().


2.1. Interactions
-----------------

kpCommandSize methods are generally only called inside implementations of
kpCommand::size().

kpCommand, kpNamedCommand and kpMacroCommand are referenced extensively
outside this package.  There is a substantial hierarchy of classes derived
from these base classes, for each operation that acts on the document.
Implementations of execute() and unexecute() should mutate the kpDocument
returned by document() and control views using the kpViewManager returned
by viewManager().  In order to reduce coupling with classes outside of the
package, accesses to such classes should be done in kpCommandEnvironment
only (see the environments/ documentation).

execute() and unexecute() may be called without a command being in
the command history.

Commands are generally created, and added to the command history, by tools
or by kpMainWindow.  Sometimes they are deleted and never placed in the
command history as, for instance, a tool may construct a kpCommand while
the user is dragging a shape but discards it when the user cancels that
shape.

A single kpCommandHistory is stored per kpMainWindow and accessible
through the user-visible undo/redo actions.


2.2. External Interface
-----------------------

In this section, we highlight the difference between command classes that
do not need "finalization" and those that do.

Some command classes are considered to be complete after construction, such
as the image effect and transform commands.

Other command classes (esp. the ones corresponding to tools) are
constructed at the start of a shape drag and methods are called to update
the command as the drag progresses e.g. kpToolFlowCommand for brushes, pens
and erasers.  Commonly, these classes have a finalize() method which must
be called at the end of the drag, before adding the command to the command
history or if the drag is cancelled, before deleting the command.

For instance, finalize() might crop the saved image to the dirty rectangle
or disable a timer.  Failure to call finalize() results in undefined
behaviour such as redoing not working (due to a saved image not be cropped)
or crashes (due to the timer firing when the drag is no longer active).

TODO: this is bad class design and finalize() should be called
      automatically.


2.3. Internals
--------------

In this section, we describe the implementation of command classes derived
from the kpCommand base class.

name() should be the name of the corresponding tool e.g. “Line” or “Curve”.
If the selection was involved, you should prepend “Selection: “ (note the
trailing space) to the name (e.g. “Selection: Reduce to Grayscale”) instead
of “Reduce to Grayscale” (which is for if the entire image was changed).

size() is used for the purposes of clipping the command history to keep
KolourPaint memory usage sane.

execute() and unexecute() are usually called by kpCommandHistory in
response to the user triggering the redo and undo actions, respectively.

execute() should store a copy of the area of the document that will be
modified and then actually modify the document e.g. draw the line.  Note
that this copy is not normally stored in the constructor to save memory:
consider the case after a user undoes a command – we simply do not need
that copy at the moment as the document has not been modified.

unexecute() should restore that area of the document and erase the copy, to
save memory.  If it is an invertible operation (e.g. Invert or Flip), you
can actually avoid storing a copy of the dirty area in execute() and simply
apply the operation again.  Although this is slower, we value memory rather
than performance, for a larger command history (see size() above).

In both execute() and unexecute(), for a command created by a non-drag
operation (e.g. Image effects), Qt::WaitCursor should be used as the
operation usually takes quite some time -– see the kpSetOverrideCursorSaver
class.  We don't use wait cursors for drag operations (e.g. lines) as they
are usually fast to render and the cursor flicker is distracting.  Of
course, this is not a hard-and-fast rule.


3. Derived Classes
~~~~~~~~~~~~~~~~~~

3.1. commands/imagelib/
-----------------------

These commands are based on the content of the top-level imagelib/ hierarchy.
Of course, they also use methods in imagelib/.


[>>>] kpDocumentMetaInfoCommand

Command for changing kpDocument's kpDocumentMetaInfo.


3.1.1. commands/imagelib/effects/
---------------------------------

All classes are derived from kpEffectCommandBase.

Instances are created by the respectively named widget derived from
kpEffectWidgetBase, and use the respectively named effect in
imagelib/effects/.  Mostly, these are created as a result of "Image / More
Effects...".


3.1.2. commands/imagelib/transforms/
------------------------------------

These commands are usually created by kpMainWindow, in response to the
respectively named menu item in the "Image" menu.

[>>>] kpTransformFlipCommand


[>>>] kpTransformResizeScaleCommand


[>>>] kpTransformRotateCommand


[>>>] kpTransformSkewCommand


3.2. commands/tools/
--------------------

These are commands created by the respectively named tools in the top-level
tools/ hierarchy.

[>>>] kpToolColorPickerCommand

[>>>] kpToolFloodFillCommand


3.2.1. commands/tools/flow/
...........................

[>>>] kpToolFlowCommand

The single command for all kpToolFlowBase-derived tools.


3.2.2. commands/tools/polygonal/
................................

[>>>] kpToolPolygonalCommand

The single command for all kpToolPolygonalBase-derived tools.


3.2.3. commands/tools/rectangular/
..................................

[>>>] kpToolRectangularCommand

The single command for all kpToolRectangularBase-derived tools.


3.2.4. commands/tools/selection/
................................

All commands are derived from one of the kpCommand foundation classes,
except for:

                    kpAbstractSelectionContentCommand
                    ^                               ^
                    |                               |
kpToolSelectionPullFromDocumentCommand    kpToolTextGiveContentCommand

Please refer to the layers/ documentation for more information about
selections, including the above 2 commands.


[>>>] kpToolSelectionCreateCommand

Creates a floating selection or selection border.


[>>>] kpToolSelectionDestroyCommand

Deletes a floating selection.  You can delete a selection border by using
kpDocument::selectionDelete() directly, without adding a command.


[>>>] kpToolSelectionMoveCommand


[>>>] kpToolSelectionResizeScaleCommand


[>>>] text/kpToolTextBackspaceCommand


[>>>] text/kpToolTextChangeStyleCommand


[>>>] text/kpToolTextDeleteCommand


[>>>] text/kpToolTextEnterCommand


[>>>] text/kpToolTextGiveContentCommand

Converts a text border (no text lines) to a text selection with 1 empty
text line.  This must be executed before any manipulations can be made
to a text selection.

Text analogue of kpToolSelectionPullFromDocumentCommand.


[>>>] text/kpToolTextInsertCommand


4. Effects of the Linear Command History
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Interestingly, the Color Picker is undo-able and redo-able even though it
does not affect the document.  This is because we want to protect the
user's hard work looking for a particular needle color in the image
haystack.  We may want to rethink this in the future as making something a
command has a nasty side effect with linear command histories, as we now
discuss:

Suppose, under KolourPaint's linear command history (which is similar to
Konqueror's Back / Forward buttons and KWrite's Undo/Redo), one has
performed the Line, Circle and Rectangle commands.  Undoing would remove
the rectangle.  Undoing again would remove the circle.  Undoing yet again
would remove the line.  However, it's possible to “undo the undo” and
return to the states before we undid anything.  If we now redo, we traverse
the command history in the opposite direction: a redo recreates the line, a
second redo recreates the circle and a third redo recreates the rectangle.

The problem is suppose we had pressed Undo those 3 times.  If we were now
to do something that adds a command to the history e.g. draw a different
line, draw a polygon or use the Color Picker, the redo history is cleared.
It is not possible to redo the Line, Circle or Rectangle commands by
pressing any combination of undo and redo.  A tree-like command history
would solve this problem but would probably add quite some UI complexity
and memory footprint.
