BEGIN
Totally push down drawing methods into respective tools.

kpToolEraser & kpToolBrush both derive from kpToolDrawsPixmapsBase now
(where the drawing methods are defined for them).

The only logic that changed that may cause us trouble is that even for
the ordinary pen tool, we now look at m_brushPixmap:

+        rect = neededRect (rect, m_brushPixmap [m_mouseButton].width ());

END

diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolbrush.cpp head/kolourpaint/tools/kptoolbrush.cpp
--- base/kolourpaint/tools/kptoolbrush.cpp	2005-06-23 14:18:16.000000000 +1000
+++ head/kolourpaint/tools/kptoolbrush.cpp	2005-06-23 16:55:43.568913424 +1000
@@ -32,7 +32,7 @@
 
 
 kpToolBrush::kpToolBrush (kpMainWindow *mainWindow)
-    : kpToolPen (kpToolPen::Brush,
+    : kpToolDrawsPixmapsBase (kpToolPen::Brush,
                  i18n ("Brush"),
                  i18n ("Draw using brushes of different shapes and sizes"),
                  Qt::Key_B,
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolbrush.h head/kolourpaint/tools/kptoolbrush.h
--- base/kolourpaint/tools/kptoolbrush.h	2005-06-23 14:38:35.000000000 +1000
+++ head/kolourpaint/tools/kptoolbrush.h	2005-06-23 17:38:40.185208208 +1000
@@ -30,10 +30,10 @@
 #define KP_TOOL_BRUSH_H
 
 
-#include <kptoolpen.h>
+#include <kptoolflowpixmapbase.h>
 
 
-class kpToolBrush : public kpToolPen
+class kpToolBrush : public kpToolDrawsPixmapsBase
 {
 Q_OBJECT
 
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolcolorwasher.cpp head/kolourpaint/tools/kptoolcolorwasher.cpp
--- base/kolourpaint/tools/kptoolcolorwasher.cpp	2005-06-23 14:18:16.000000000 +1000
+++ head/kolourpaint/tools/kptoolcolorwasher.cpp	2005-06-23 17:45:01.344263224 +1000
@@ -142,4 +142,240 @@ kpToolPenCommand *kpToolColorWasher::new
     return new kpToolPenCommand (i18n ("Color Eraser"), mainWindow ());
 }
 
+
+
+bool kpToolColorWasher::wash (QPainter *painter, QPainter *maskPainter,
+                      const QImage &image,
+                      const kpColor &colorToReplace,
+                      const QRect &imageRect, int plotx, int ploty)
+{
+    return wash (painter, maskPainter, image, colorToReplace, imageRect, hotRect (plotx, ploty));
+}
+
+bool kpToolColorWasher::wash (QPainter *painter, QPainter *maskPainter,
+                      const QImage &image,
+                      const kpColor &colorToReplace,
+                      const QRect &imageRect, const QRect &drawRect)
+{
+    bool didSomething = false;
+
+#if DEBUG_KP_TOOL_COLOR_WASHER && 0
+    kdDebug () << "kpToolColorWasher::wash(imageRect=" << imageRect
+               << ",drawRect=" << drawRect
+               << ")" << endl;
+#endif
+
+// make use of scanline coherence
+#define FLUSH_LINE()                                     \
+{                                                        \
+    if (painter && painter->isActive ())                 \
+        painter->drawLine (startDrawX, y, x - 1, y);     \
+    if (maskPainter && maskPainter->isActive ())         \
+        maskPainter->drawLine (startDrawX, y, x - 1, y); \
+    didSomething = true;                                 \
+    startDrawX = -1;                                     \
+}
+
+    const int maxY = drawRect.bottom () - imageRect.top ();
+
+    const int minX = drawRect.left () - imageRect.left ();
+    const int maxX = drawRect.right () - imageRect.left ();
+
+    for (int y = drawRect.top () - imageRect.top ();
+         y <= maxY;
+         y++)
+    {
+        int startDrawX = -1;
+
+        int x;  // for FLUSH_LINE()
+        for (x = minX; x <= maxX; x++)
+        {
+        #if DEBUG_KP_TOOL_COLOR_WASHER && 0
+            fprintf (stderr, "y=%i x=%i colorAtPixel=%08X colorToReplace=%08X ... ",
+                     y, x,
+                     kpPixmapFX::getColorAtPixel (image, QPoint (x, y)).toQRgb (),
+                     colorToReplace.toQRgb ());
+        #endif
+            if (kpPixmapFX::getColorAtPixel (image, QPoint (x, y)).isSimilarTo (colorToReplace, processedColorSimilarity ()))
+            {
+            #if DEBUG_KP_TOOL_COLOR_WASHER && 0
+                fprintf (stderr, "similar\n");
+            #endif
+                if (startDrawX < 0)
+                    startDrawX = x;
+            }
+            else
+            {
+            #if DEBUG_KP_TOOL_COLOR_WASHER && 0
+                fprintf (stderr, "different\n");
+            #endif
+                if (startDrawX >= 0)
+                    FLUSH_LINE ();
+            }
+        }
+
+        if (startDrawX >= 0)
+            FLUSH_LINE ();
+    }
+
+#undef FLUSH_LINE
+
+    return didSomething;
+}
+
+
+
+bool kpToolColorWasher::drawShouldProceed (const QPoint & /*thisPoint*/,
+    const QPoint & /*lastPoint*/,
+    const QRect & /*normalizedRect*/)
+{
+    if (foregroundColor () == backgroundColor () &&
+        processedColorSimilarity () == 0)
+    {
+        return false;
+    }
+    
+    return true;
+}
+
+
+void kpToolColorWasher::drawPoint (const QPoint &)
+{            
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    kdDebug () << "Washing pixmap (immediate)" << endl;
+    QTime timer;
+#endif
+    QRect rect = hotRect ();
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    timer.start ();
+#endif
+    QPixmap pixmap = document ()->getPixmapAt (rect);
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    kdDebug () << "\tget from doc: " << timer.restart () << "ms" << endl;
+#endif
+    const QImage image = kpPixmapFX::convertToImage (pixmap);
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    kdDebug () << "\tconvert to image: " << timer.restart () << "ms" << endl;
+#endif
+    QPainter painter, maskPainter;
+    QBitmap maskBitmap;
+
+    if (color (m_mouseButton).isOpaque ())
+    {
+        painter.begin (&pixmap);
+        painter.setPen (color (m_mouseButton).toQColor ());
+    }
+
+    if (color (m_mouseButton).isTransparent () ||
+        pixmap.mask ())
+    {
+        maskBitmap = kpPixmapFX::getNonNullMask (pixmap);
+        maskPainter.begin (&maskBitmap);
+        maskPainter.setPen (color (m_mouseButton).maskColor ());
+    }
+
+    bool didSomething = wash (&painter, &maskPainter,
+                                image,
+                                color (1 - m_mouseButton)/*color to replace*/,
+                                rect, rect);
+
+    if (painter.isActive ())
+        painter.end ();
+
+    if (maskPainter.isActive ())
+        maskPainter.end ();
+
+    if (didSomething)
+    {
+        if (!maskBitmap.isNull ())
+            pixmap.setMask (maskBitmap);
+
+    #if DEBUG_KP_TOOL_COLOR_WASHER
+        kdDebug () << "\twashed: " << timer.restart () << "ms" << endl;
+    #endif
+        document ()->setPixmapAt (pixmap, hotPoint ());
+    #if DEBUG_KP_TOOL_COLOR_WASHER
+        kdDebug () << "\tset doc: " << timer.restart () << "ms" << endl;
+    #endif
+        m_currentCommand->updateBoundingRect (hotRect ());
+    #if DEBUG_KP_TOOL_COLOR_WASHER
+        kdDebug () << "\tupdate boundingRect: " << timer.restart () << "ms" << endl;
+        kdDebug () << "\tdone" << endl;
+    #endif
+    }
+
+#if DEBUG_KP_TOOL_COLOR_WASHER && 1
+    kdDebug () << endl;
+#endif
+}
+
+bool kpToolColorWasher::drawLine (QPixmap *pixmap, const QRect &docRect,
+    const QPoint &thisPoint, const QPoint &lastPoint)
+{
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    kdDebug () << "Washing pixmap (w=" << rect.width ()
+                << ",h=" << rect.height () << ")" << endl;
+    QTime timer;
+    int convAndWashTime;
+#endif
+
+    QBitmap maskBitmap;    
+    QPainter painter, maskPainter;
+
+    drawLineSetupPainterMask (pixmap,
+        &maskBitmap,
+        &painter, &maskPainter);
+
+        
+    QImage image;
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    timer.start ();
+#endif
+    image = kpPixmapFX::convertToImage (*pixmap);
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    convAndWashTime = timer.restart ();
+    kdDebug () << "\tconvert to image: " << convAndWashTime << " ms" << endl;
+#endif
+
+    bool didSomething = false;
+
+    kpColor colorToReplace = color (1 - m_mouseButton);
+
+    QValueVector <QPoint> points = interpolatePoints (docRect,
+        thisPoint, lastPoint);
+    for (QValueVector <QPoint>::const_iterator pit = points.begin ();
+            pit != points.end ();
+            pit++)
+    {
+        const int XXX = (*pit).x (), YYY = (*pit).y ();
+        
+        if (wash (&painter, &maskPainter, image,
+                    colorToReplace,
+                    docRect, XXX + docRect.left (), YYY + docRect.top ()))
+        {
+            didSomething = true;
+        }
+    }
+
+
+    if (!didSomething)
+        maskBitmap = QBitmap ();
+        
+    drawLineTearDownPainterMask (pixmap,
+        &maskBitmap,
+        &painter, &maskPainter);
+
+
+#if DEBUG_KP_TOOL_COLOR_WASHER
+    int ms = timer.restart ();
+    kdDebug () << "\ttried to wash: " << ms << "ms"
+                << " (" << (ms ? (rect.width () * rect.height () / ms) : -1234)
+                << " pixels/ms)"
+                << endl;
+    convAndWashTime += ms;
+#endif
+
+    return didSomething;
+}
+
 #include <kptoolcolorwasher.moc>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolcolorwasher.h head/kolourpaint/tools/kptoolcolorwasher.h
--- base/kolourpaint/tools/kptoolcolorwasher.h	2005-06-23 14:38:35.000000000 +1000
+++ head/kolourpaint/tools/kptoolcolorwasher.h	2005-06-23 17:36:58.423678312 +1000
@@ -42,6 +42,16 @@ public:
     virtual ~kpToolColorWasher ();
 
 
+protected:
+    bool wash (QPainter *painter, QPainter *maskPainter,
+               const QImage &image,
+               const kpColor &colorToReplace,
+               const QRect &imageRect, int plotx, int ploty);
+    bool wash (QPainter *painter, QPainter *maskPainter,
+               const QImage &image,
+               const kpColor &colorToReplace,
+               const QRect &imageRect, const QRect &drawRect);
+
 public:
     virtual void globalDraw ();
     
@@ -50,8 +60,21 @@ protected:
     virtual QString haventBegunDrawUserMessage () const;
     virtual kpToolPenCommand *newCommand () const;
     
+    virtual bool drawShouldProceed (const QPoint &thisPoint,
+        const QPoint &lastPoint,
+        const QRect &normalizedRect);
+
     virtual bool haveSquareBrushes () const { return true; }
     virtual bool colorsAreSwapped () const { return true; }
+    
+
+
+    virtual void drawPoint (const QPoint &point);
+    virtual bool drawLine (QPixmap *pixmap,
+        const QRect &docRect,
+        const QPoint &thisPoint, const QPoint &lastPoint);
+
+
 };
 
 
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowpixmapbase.cpp head/kolourpaint/tools/kptoolflowpixmapbase.cpp
--- base/kolourpaint/tools/kptoolflowpixmapbase.cpp	1970-01-01 10:00:00.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowpixmapbase.cpp	2005-06-23 17:46:17.187733264 +1000
@@ -0,0 +1,97 @@
+
+/*
+   Copyright (c) 2003,2004,2005 Clarence Dang <dang@kde.org>
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include <kptoolflowpixmapbase.h>
+
+#include <qbitmap.h>
+
+#include <kpcolor.h>
+#include <kpdocument.h>
+#include <kppixmapfx.h>
+
+kpToolDrawsPixmapsBase::kpToolDrawsPixmapsBase (Mode mode, const QString &text, const QString &description,
+            int key,
+            kpMainWindow *mainWindow, const char *name)
+    : kpToolPen (mode, text, description, key, mainWindow, name)
+{
+}
+
+kpToolDrawsPixmapsBase::~kpToolDrawsPixmapsBase ()
+{
+}
+
+
+void kpToolDrawsPixmapsBase::drawPoint (const QPoint & /*point*/)
+{            
+    if (color (m_mouseButton).isOpaque ())
+        document ()->paintPixmapAt (m_brushPixmap [m_mouseButton], hotPoint ());
+    else
+    {
+        kpPixmapFX::paintMaskTransparentWithBrush (document ()->pixmap (),
+            hotPoint (),
+            kpPixmapFX::getNonNullMask (m_brushPixmap [m_mouseButton]));
+        document ()->slotContentsChanged (hotRect ());
+    }
+
+    m_currentCommand->updateBoundingRect (hotRect ());
+}
+
+
+
+bool kpToolDrawsPixmapsBase::drawLine (QPixmap *pixmap,
+    const QRect &docRect,
+    const QPoint &thisPoint, const QPoint &lastPoint)
+{
+    QValueVector <QPoint> points = interpolatePoints (docRect,
+        thisPoint, lastPoint);
+        
+    for (QValueVector <QPoint>::const_iterator pit = points.begin ();
+         pit != points.end ();
+         pit++)
+    {
+        const int XXX = (*pit).x (), YYY = (*pit).y ();
+        
+        if (!color (m_mouseButton).isTransparent ())
+        {
+            kpPixmapFX::paintPixmapAt (pixmap,
+                hotPoint (XXX, YYY),
+                m_brushPixmap [m_mouseButton]);
+        }
+        else
+        {
+            kpPixmapFX::paintMaskTransparentWithBrush (pixmap,
+                hotPoint (XXX, YYY),
+                kpPixmapFX::getNonNullMask (m_brushPixmap [m_mouseButton]));
+        }
+    }
+
+    return true;
+}
+
+    
+#include <kptoolflowpixmapbase.moc>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowpixmapbase.h head/kolourpaint/tools/kptoolflowpixmapbase.h
--- base/kolourpaint/tools/kptoolflowpixmapbase.h	1970-01-01 10:00:00.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowpixmapbase.h	2005-06-23 17:41:28.138675400 +1000
@@ -0,0 +1,62 @@
+
+/*
+   Copyright (c) 2003,2004,2005 Clarence Dang <dang@kde.org>
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef KP_TOOL_DRAWS_PIXMAPS_BASE
+#define KP_TOOL_DRAWS_PIXMAPS_BASE
+
+
+#include <kptoolpen.h>
+
+
+/**
+ * @short Abstract base call for all continuous tools that draw pixmaps
+ * (e.g. Brush, Eraser).
+ *
+ * @author Clarence Dang <dang@kde.org>
+ */
+class kpToolDrawsPixmapsBase : public kpToolPen
+{
+Q_OBJECT
+
+public:
+    kpToolDrawsPixmapsBase (Mode mode, const QString &text, const QString &description,
+               int key,
+               kpMainWindow *mainWindow, const char *name);
+    virtual ~kpToolDrawsPixmapsBase ();
+    
+protected:
+    virtual void drawPoint (const QPoint &point);
+    virtual bool drawLine (QPixmap *pixmap,
+        const QRect &docRect,
+        const QPoint &thisPoint, const QPoint &lastPoint);
+
+
+};
+
+
+#endif  // KP_TOOL_DRAWS_PIXMAPS_BASE
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptooleraser.cpp head/kolourpaint/tools/kptooleraser.cpp
--- base/kolourpaint/tools/kptooleraser.cpp	2005-06-23 14:18:16.000000000 +1000
+++ head/kolourpaint/tools/kptooleraser.cpp	2005-06-23 16:55:59.298522160 +1000
@@ -38,7 +38,7 @@
 
 
 kpToolEraser::kpToolEraser (kpMainWindow *mainWindow)
-    : kpToolPen (kpToolPen::Eraser,
+    : kpToolDrawsPixmapsBase (kpToolPen::Eraser,
                  i18n ("Eraser"), i18n ("Lets you rub out mistakes"),
                  Qt::Key_A,
                  mainWindow, "tool_eraser")
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptooleraser.h head/kolourpaint/tools/kptooleraser.h
--- base/kolourpaint/tools/kptooleraser.h	2005-06-23 14:38:35.000000000 +1000
+++ head/kolourpaint/tools/kptooleraser.h	2005-06-23 17:38:26.662264008 +1000
@@ -30,10 +30,10 @@
 #define KP_TOOL_ERASER_H
 
 
-#include <kptoolpen.h>
+#include <kptoolflowpixmapbase.h>
 
 
-class kpToolEraser : public kpToolPen
+class kpToolEraser : public kpToolDrawsPixmapsBase
 {
 Q_OBJECT
 
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolpen.cpp head/kolourpaint/tools/kptoolpen.cpp
--- base/kolourpaint/tools/kptoolpen.cpp	2005-06-23 16:38:29.542109392 +1000
+++ head/kolourpaint/tools/kptoolpen.cpp	2005-06-23 17:44:32.408662104 +1000
@@ -257,86 +257,7 @@ void kpToolPen::hover (const QPoint &poi
     setUserShapePoints (point);
 }
 
-bool kpToolPen::wash (QPainter *painter, QPainter *maskPainter,
-                      const QImage &image,
-                      const kpColor &colorToReplace,
-                      const QRect &imageRect, int plotx, int ploty)
-{
-    return wash (painter, maskPainter, image, colorToReplace, imageRect, hotRect (plotx, ploty));
-}
-
-bool kpToolPen::wash (QPainter *painter, QPainter *maskPainter,
-                      const QImage &image,
-                      const kpColor &colorToReplace,
-                      const QRect &imageRect, const QRect &drawRect)
-{
-    bool didSomething = false;
-
-#if DEBUG_KP_TOOL_PEN && 0
-    kdDebug () << "kpToolPen::wash(imageRect=" << imageRect
-               << ",drawRect=" << drawRect
-               << ")" << endl;
-#endif
-
-// make use of scanline coherence
-#define FLUSH_LINE()                                     \
-{                                                        \
-    if (painter && painter->isActive ())                 \
-        painter->drawLine (startDrawX, y, x - 1, y);     \
-    if (maskPainter && maskPainter->isActive ())         \
-        maskPainter->drawLine (startDrawX, y, x - 1, y); \
-    didSomething = true;                                 \
-    startDrawX = -1;                                     \
-}
-
-    const int maxY = drawRect.bottom () - imageRect.top ();
-
-    const int minX = drawRect.left () - imageRect.left ();
-    const int maxX = drawRect.right () - imageRect.left ();
-
-    for (int y = drawRect.top () - imageRect.top ();
-         y <= maxY;
-         y++)
-    {
-        int startDrawX = -1;
-
-        int x;  // for FLUSH_LINE()
-        for (x = minX; x <= maxX; x++)
-        {
-        #if DEBUG_KP_TOOL_PEN && 0
-            fprintf (stderr, "y=%i x=%i colorAtPixel=%08X colorToReplace=%08X ... ",
-                     y, x,
-                     kpPixmapFX::getColorAtPixel (image, QPoint (x, y)).toQRgb (),
-                     colorToReplace.toQRgb ());
-        #endif
-            if (kpPixmapFX::getColorAtPixel (image, QPoint (x, y)).isSimilarTo (colorToReplace, processedColorSimilarity ()))
-            {
-            #if DEBUG_KP_TOOL_PEN && 0
-                fprintf (stderr, "similar\n");
-            #endif
-                if (startDrawX < 0)
-                    startDrawX = x;
-            }
-            else
-            {
-            #if DEBUG_KP_TOOL_PEN && 0
-                fprintf (stderr, "different\n");
-            #endif
-                if (startDrawX >= 0)
-                    FLUSH_LINE ();
-            }
-        }
-
-        if (startDrawX >= 0)
-            FLUSH_LINE ();
-    }
-
-#undef FLUSH_LINE
-
-    return didSomething;
-}
-
-void kpToolPen::drawPixel (const QPoint &thisPoint)
+void kpToolPen::drawPoint (const QPoint &point)
 {
     QPixmap pixmap (1, 1);
 
@@ -356,107 +277,12 @@ void kpToolPen::drawPixel (const QPoint 
     }
 
     // draw onto doc
-    document ()->setPixmapAt (pixmap, thisPoint);
-
-    m_currentCommand->updateBoundingRect (thisPoint);
-}
-
-void kpToolPen::drawPixels (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &rect, QPainter *painter, QPainter *maskPainter)
-{
-    QPoint sp = lastPoint - rect.topLeft (), ep = thisPoint - rect.topLeft ();
-    if (painter->isActive ())
-        painter->drawLine (sp, ep);
-
-    if (maskPainter->isActive ())
-        maskPainter->drawLine (sp, ep);
-}
-
-void kpToolPen::drawPixmap ()
-{            
-    if (color (m_mouseButton).isOpaque ())
-        document ()->paintPixmapAt (m_brushPixmap [m_mouseButton], hotPoint ());
-    else
-    {
-        kpPixmapFX::paintMaskTransparentWithBrush (document ()->pixmap (),
-            hotPoint (),
-            kpPixmapFX::getNonNullMask (m_brushPixmap [m_mouseButton]));
-        document ()->slotContentsChanged (hotRect ());
-    }
+    document ()->setPixmapAt (pixmap, point);
 
-    m_currentCommand->updateBoundingRect (hotRect ());
+    m_currentCommand->updateBoundingRect (point);
 }
 
 
-void kpToolPen::washPixmap ()
-{            
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "Washing pixmap (immediate)" << endl;
-    QTime timer;
-#endif
-    QRect rect = hotRect ();
-#if DEBUG_KP_TOOL_PEN
-    timer.start ();
-#endif
-    QPixmap pixmap = document ()->getPixmapAt (rect);
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "\tget from doc: " << timer.restart () << "ms" << endl;
-#endif
-    const QImage image = kpPixmapFX::convertToImage (pixmap);
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "\tconvert to image: " << timer.restart () << "ms" << endl;
-#endif
-    QPainter painter, maskPainter;
-    QBitmap maskBitmap;
-
-    if (color (m_mouseButton).isOpaque ())
-    {
-        painter.begin (&pixmap);
-        painter.setPen (color (m_mouseButton).toQColor ());
-    }
-
-    if (color (m_mouseButton).isTransparent () ||
-        pixmap.mask ())
-    {
-        maskBitmap = kpPixmapFX::getNonNullMask (pixmap);
-        maskPainter.begin (&maskBitmap);
-        maskPainter.setPen (color (m_mouseButton).maskColor ());
-    }
-
-    bool didSomething = wash (&painter, &maskPainter,
-                                image,
-                                color (1 - m_mouseButton)/*color to replace*/,
-                                rect, rect);
-
-    if (painter.isActive ())
-        painter.end ();
-
-    if (maskPainter.isActive ())
-        maskPainter.end ();
-
-    if (didSomething)
-    {
-        if (!maskBitmap.isNull ())
-            pixmap.setMask (maskBitmap);
-
-    #if DEBUG_KP_TOOL_PEN
-        kdDebug () << "\twashed: " << timer.restart () << "ms" << endl;
-    #endif
-        document ()->setPixmapAt (pixmap, hotPoint ());
-    #if DEBUG_KP_TOOL_PEN
-        kdDebug () << "\tset doc: " << timer.restart () << "ms" << endl;
-    #endif
-        m_currentCommand->updateBoundingRect (hotRect ());
-    #if DEBUG_KP_TOOL_PEN
-        kdDebug () << "\tupdate boundingRect: " << timer.restart () << "ms" << endl;
-        kdDebug () << "\tdone" << endl;
-    #endif
-    }
-
-#if DEBUG_KP_TOOL_PEN && 1
-    kdDebug () << endl;
-#endif
-}
-
 QValueVector <QPoint> kpToolPen::interpolatePoints (const QRect &rect/*TODO:take me away*/,
     const QPoint &thisPoint, const QPoint &lastPoint)
 {
@@ -544,226 +370,81 @@ QValueVector <QPoint> kpToolPen::interpo
     return ret;
 }
 
-void kpToolPen::drawPixel_Many (const QPoint &thisPoint, const QPoint &lastPoint)
-{
-    // find bounding rectangle
-    QRect rect = QRect (thisPoint, lastPoint).normalize ();
-
-    const kpColor c = color (m_mouseButton);
-    bool transparent = c.isTransparent ();
-
-    QPixmap pixmap = document ()->getPixmapAt (rect);
-    QBitmap maskBitmap;
 
-    QPainter painter, maskPainter;
+void kpToolPen::drawLineSetupPainterMask (QPixmap *pixmap,
+    QBitmap *maskBitmap,
+    QPainter *painter, QPainter *maskPainter)
+{
+    const kpColor col = color (m_mouseButton);
 
-    if (!transparent)
+    if (!col.isTransparent ())
     {
-        painter.begin (&pixmap);
-        painter.setPen (c.toQColor ());
+        painter->begin (pixmap);
+        painter->setPen (col.toQColor ());
     }
 
-    if (transparent || pixmap.mask ())
+    if (col.isTransparent () || pixmap->mask ())
     {
-        maskBitmap = kpPixmapFX::getNonNullMask (pixmap);
-        maskPainter.begin (&maskBitmap);
-        maskPainter.setPen (c.maskColor ());
+        *maskBitmap = kpPixmapFX::getNonNullMask (*pixmap);
+        maskPainter->begin (maskBitmap);
+        maskPainter->setPen (col.maskColor ());
     }
-
-    
-    drawPixels (thisPoint, lastPoint, rect, &painter, &maskPainter);
-
-    if (painter.isActive ())
-        painter.end ();
-
-    if (maskPainter.isActive ())
-        maskPainter.end ();
-
-
-
-    if (!maskBitmap.isNull ())
-        pixmap.setMask (maskBitmap);
-
-    // draw onto doc
-    document ()->setPixmapAt (pixmap, rect.topLeft ());
-
-    m_currentCommand->updateBoundingRect (rect);
 }
 
-void kpToolPen::drawPixmap_Many (const QPoint &thisPoint, const QPoint &lastPoint)
-{
-    // find bounding rectangle
-    QRect rect = QRect (thisPoint, lastPoint).normalize ();
-    rect = neededRect (rect, m_brushPixmap [m_mouseButton].width ());
-
-    const kpColor c = color (m_mouseButton);
-    bool transparent = c.isTransparent ();
-
-    QPixmap pixmap = document ()->getPixmapAt (rect);
-    QBitmap maskBitmap;
-
-    QPainter painter, maskPainter;
-
-    QImage image;
-
-    QValueVector <QPoint> points = interpolatePoints (rect,
-        thisPoint, lastPoint);
-    for (QValueVector <QPoint>::const_iterator pit = points.begin ();
-            pit != points.end ();
-            pit++)
-    {
-        const int XXX = (*pit).x (), YYY = (*pit).y ();
-        
-        if (!transparent)
-        {
-            kpPixmapFX::paintPixmapAt (&pixmap,
-                hotPoint (XXX, YYY),
-                m_brushPixmap [m_mouseButton]);
-        }
-        else
-        {
-            kpPixmapFX::paintMaskTransparentWithBrush (&pixmap,
-                hotPoint (XXX, YYY),
-                kpPixmapFX::getNonNullMask (m_brushPixmap [m_mouseButton]));
-        }
-    }
-
-    if (painter.isActive ())
-        painter.end ();
-
-    if (maskPainter.isActive ())
-        maskPainter.end ();
+void kpToolPen::drawLineTearDownPainterMask (QPixmap *pixmap,
+    const QBitmap *maskBitmap,
+    QPainter *painter, QPainter *maskPainter)
+{        
+    if (painter->isActive ())
+        painter->end ();
 
+    if (maskPainter->isActive ())
+        maskPainter->end ();
 
-    if (!maskBitmap.isNull ())
-        pixmap.setMask (maskBitmap);
 
-    // draw onto doc
-    document ()->setPixmapAt (pixmap, rect.topLeft ());
 
-    m_currentCommand->updateBoundingRect (rect);
+    if (!maskBitmap->isNull ())
+        pixmap->setMask (*maskBitmap);
 }
 
-void kpToolPen::washPixmap_Many (const QPoint &thisPoint, const QPoint &lastPoint)
+        
+bool kpToolPen::drawLine (QPixmap *pixmap, const QRect &docRect,
+    const QPoint &thisPoint, const QPoint &lastPoint)
 {
-    // find bounding rectangle
-    QRect rect = QRect (thisPoint, lastPoint).normalize ();
-    rect = neededRect (rect, m_brushPixmap [m_mouseButton].width ());
-
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "Washing pixmap (w=" << rect.width ()
-                << ",h=" << rect.height () << ")" << endl;
-    QTime timer;
-    int convAndWashTime;
-#endif
-
-    const kpColor c = color (m_mouseButton);
-    bool transparent = c.isTransparent ();
-
-    QPixmap pixmap = document ()->getPixmapAt (rect);
     QBitmap maskBitmap;
-
     QPainter painter, maskPainter;
-
-    if (!transparent)
-    {
-        painter.begin (&pixmap);
-        painter.setPen (c.toQColor ());
-    }
-
-    if (transparent || pixmap.mask ())
-    {
-        maskBitmap = kpPixmapFX::getNonNullMask (pixmap);
-        maskPainter.begin (&maskBitmap);
-        maskPainter.setPen (c.maskColor ());
-    }
-
-    QImage image;
-#if DEBUG_KP_TOOL_PEN
-    timer.start ();
-#endif
-    image = kpPixmapFX::convertToImage (pixmap);
-#if DEBUG_KP_TOOL_PEN
-    convAndWashTime = timer.restart ();
-    kdDebug () << "\tconvert to image: " << convAndWashTime << " ms" << endl;
-#endif
-
-    bool didSomething = false;
-
-    kpColor colorToReplace;
-
-    if (m_mode & WashesPixmaps)
-        colorToReplace = color (1 - m_mouseButton);
-
-    QValueVector <QPoint> points = interpolatePoints (rect,
-        thisPoint, lastPoint);
-    for (QValueVector <QPoint>::const_iterator pit = points.begin ();
-            pit != points.end ();
-            pit++)
-    {
-        const int XXX = (*pit).x (), YYY = (*pit).y ();
+    
+    drawLineSetupPainterMask (pixmap,
+        &maskBitmap,
+        &painter, &maskPainter);
+    
         
-        if (wash (&painter, &maskPainter, image,
-                    colorToReplace,
-                    rect, XXX + rect.left (), YYY + rect.top ()))
-        {
-            didSomething = true;
-        }
-    }
-
-
+    const QPoint sp = lastPoint - docRect.topLeft (),
+                 ep = thisPoint - docRect.topLeft ();
+                 
     if (painter.isActive ())
-        painter.end ();
+        painter.drawLine (sp, ep);
 
     if (maskPainter.isActive ())
-        maskPainter.end ();
-
-#if DEBUG_KP_TOOL_PEN
-    int ms = timer.restart ();
-    kdDebug () << "\ttried to wash: " << ms << "ms"
-                << " (" << (ms ? (rect.width () * rect.height () / ms) : -1234)
-                << " pixels/ms)"
-                << endl;
-    convAndWashTime += ms;
-#endif
-
-
-    if (didSomething)
-    {
-        if (!maskBitmap.isNull ())
-            pixmap.setMask (maskBitmap);
+        maskPainter.drawLine (sp, ep);
 
-        // draw onto doc
-        document ()->setPixmapAt (pixmap, rect.topLeft ());
+ 
+    drawLineTearDownPainterMask (pixmap,
+        &maskBitmap,
+        &painter, &maskPainter);
 
-    #if DEBUG_KP_TOOL_PEN
-        int ms = timer.restart ();
-        kdDebug () << "\tset doc: " << ms << "ms" << endl;
-        convAndWashTime += ms;
-    #endif
+    
+    return true;
+}
 
-        m_currentCommand->updateBoundingRect (rect);
 
-    #if DEBUG_KP_TOOL_PEN
-        int ms = timer.restart ();
-        kdDebug () << "\tupdate boundingRect: " << ms << "ms" << endl;
-        convAndWashTime += ms;
-        kdDebug () << "\tdone (" << (convAndWashTime ? (rect.width () * rect.height () / convAndWashTime) : -1234)
-                    << " pixels/ms)"
-                    << endl;
-    #endif
-    }
 
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << endl;
-#endif
-}
 
 // virtual
 // TODO: refactor!
-void kpToolPen::draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &)
+void kpToolPen::draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &normalizedRect)
 {
-    if ((m_mode & WashesPixmaps) && (foregroundColor () == backgroundColor ()) && processedColorSimilarity () == 0)
+    if (!drawShouldProceed (thisPoint, lastPoint, normalizedRect))
         return;
 
     // sync: remember to restoreFastUpdates() in all exit paths
@@ -773,25 +454,23 @@ void kpToolPen::draw (const QPoint &this
             currentPointCardinallyNextToLast () :
             currentPointNextToLast ())
     {
-        if (m_mode & DrawsPixels)
-            drawPixel (thisPoint);
-        // Brush & Eraser
-        else if (m_mode & DrawsPixmaps)
-            drawPixmap ();
-        else if (m_mode & WashesPixmaps)
-            washPixmap ();
+        drawPoint (thisPoint);
     }
     // in reality, the system is too slow to give us all the MouseMove events
     // so we "interpolate" the missing points :)
     else
     {
-        if (m_mode & DrawsPixels)
-            drawPixel_Many (thisPoint, lastPoint);
-        // Brush & Eraser
-        else if (m_mode & DrawsPixmaps)
-            drawPixmap_Many (thisPoint, lastPoint);
-        else if (m_mode & WashesPixmaps)
-            washPixmap_Many (thisPoint, lastPoint);
+        QRect rect = QRect (thisPoint, lastPoint).normalize ();
+        rect = neededRect (rect, m_brushPixmap [m_mouseButton].width ());
+    
+        QPixmap pixmap = document ()->getPixmapAt (rect);
+
+        if (drawLine (&pixmap, rect, thisPoint, lastPoint))
+        {
+            document ()->setPixmapAt (pixmap, rect.topLeft ());
+
+            m_currentCommand->updateBoundingRect (rect);
+        }        
     }
 
     viewManager ()->restoreFastUpdates ();
@@ -970,9 +649,9 @@ void kpToolPen::updateBrushCursor (bool 
 }
 
 
-/*
- * kpToolPenCommand
- */
+//
+// kpToolPenCommand
+//
 
 kpToolPenCommand::kpToolPenCommand (const QString &name, kpMainWindow *mainWindow)
     : kpNamedCommand (name, mainWindow),
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolpen.h head/kolourpaint/tools/kptoolpen.h
--- base/kolourpaint/tools/kptoolpen.h	2005-06-23 16:38:29.609099208 +1000
+++ head/kolourpaint/tools/kptoolpen.h	2005-06-23 17:47:40.734032296 +1000
@@ -96,19 +96,23 @@ public:
     virtual void beginDraw ();
     virtual void hover (const QPoint &point);
     
-    void drawPixel (const QPoint &thisPoint);
-    void drawPixels (const QPoint &thisPoint, const QPoint &lastPoint,
-        const QRect &rect, QPainter *painter, QPainter *maskPainter);
-    void drawPixmap ();
-    void washPixmap ();
     QValueVector <QPoint> interpolatePoints (const QRect &rect/*TODO:take me away*/,
         const QPoint &thisPoint, const QPoint &lastPoint);
+
+    virtual void drawPoint (const QPoint &point);
     
-    void drawPixel_Many (const QPoint &thisPoint, const QPoint &lastPoint);
-    void drawPixmap_Many (const QPoint &thisPoint, const QPoint &lastPoint);       
-    void washPixmap_Many (const QPoint &thisPoint, const QPoint &lastPoint);
+    void drawLineSetupPainterMask (QPixmap *pixmap,
+        QBitmap *maskBitmap,
+        QPainter *painter, QPainter *maskPainter);
+    void drawLineTearDownPainterMask (QPixmap *pixmap,
+        const QBitmap *maskBitmap,
+        QPainter *painter, QPainter *maskPainter);
+        
+    virtual bool drawLine (QPixmap *pixmap, const QRect &docRect,
+        const QPoint &thisPoint, const QPoint &lastPoint);
 
-    virtual void draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &);
+    virtual bool drawShouldProceed (const QPoint & /*thisPoint*/, const QPoint & /*lastPoint*/, const QRect & /*normalizedRect*/) { return true; }
+    virtual void draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &normalizedRect);
     virtual void cancelShape ();
     virtual void releasedAllButtons ();
     virtual void endDraw (const QPoint &, const QRect &);
@@ -121,15 +125,6 @@ protected slots:
     void slotEraserSizeChanged (int size);
 
 protected:
-    bool wash (QPainter *painter, QPainter *maskPainter,
-               const QImage &image,
-               const kpColor &colorToReplace,
-               const QRect &imageRect, int plotx, int ploty);
-    bool wash (QPainter *painter, QPainter *maskPainter,
-               const QImage &image,
-               const kpColor &colorToReplace,
-               const QRect &imageRect, const QRect &drawRect);
-
     virtual kpColor color (int which);
 
     QPoint hotPoint () const;
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/Makefile.am head/kolourpaint/tools/Makefile.am
--- base/kolourpaint/tools/Makefile.am	2005-02-02 22:06:42.000000000 +1100
+++ head/kolourpaint/tools/Makefile.am	2005-06-23 16:57:27.226155128 +1000
@@ -14,6 +14,7 @@ libkolourpainttools_la_SOURCES = kptool.
     kptoolconverttograyscale.cpp \
     kptoolcrop.cpp \
     kptoolcurve.cpp \
+    kptoolflowpixmapbase.cpp \
     kptoolellipse.cpp \
     kptoolellipticalselection.cpp kptooleraser.cpp \
     kptoolflip.cpp kptoolfloodfill.cpp \
@@ -36,6 +37,7 @@ METASOURCES = kptool.moc \
     kptoolcolorpicker.moc \
     kptoolcolorwasher.moc \
     kptoolcurve.moc \
+    kptoolflowpixmapbase.moc \
     kptoolellipse.moc \
     kptooleraser.moc \
     kptoolflip.moc \
