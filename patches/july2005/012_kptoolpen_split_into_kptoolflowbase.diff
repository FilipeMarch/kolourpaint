BEGIN
* split kpToolPen into kpToolFlowBase and kpToolPen (deriving kpToolFlowBase); no more kpToolPen::m_mode!
* kpToolPenCommand -> kpToolFlowCommand and give it a separate file
* kpToolDrawsPixmapsBase -> kpToolFlowPixmapBase
* kpToolFlowBase[formerly kpToolPen]:drawLineTearDownPainterMask() adds "drawHappened" optimization hack
* Remove virtual kpToolFlowBase[formerly kpToolPen]::newCommand() (not required since have kpTool::text())
* kpview.cpp: Remove unneeded #include <kptoolpen.h>
END

diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/kpview.cpp head/kolourpaint/kpview.cpp
--- base/kolourpaint/kpview.cpp	2005-06-14 13:55:46.000000000 +1000
+++ head/kolourpaint/kpview.cpp	2005-06-23 19:10:53.275050696 +1000
@@ -59,7 +59,6 @@
 #include <kpselection.h>
 #include <kptemppixmap.h>
 #include <kptool.h>
-#include <kptoolpen.h>
 #include <kptooltoolbar.h>
 #include <kpviewmanager.h>
 #include <kpviewscrollablecontainer.h>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolbrush.cpp head/kolourpaint/tools/kptoolbrush.cpp
--- base/kolourpaint/tools/kptoolbrush.cpp	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolbrush.cpp	2005-06-23 18:56:43.268271368 +1000
@@ -32,11 +32,10 @@
 
 
 kpToolBrush::kpToolBrush (kpMainWindow *mainWindow)
-    : kpToolDrawsPixmapsBase (kpToolPen::Brush,
-                 i18n ("Brush"),
-                 i18n ("Draw using brushes of different shapes and sizes"),
-                 Qt::Key_B,
-                 mainWindow, "tool_brush")
+    : kpToolFlowPixmapBase (i18n ("Brush"),
+        i18n ("Draw using brushes of different shapes and sizes"),
+        Qt::Key_B,
+        mainWindow, "tool_brush")
 {
 }
 
@@ -50,10 +49,5 @@ QString kpToolBrush::haventBegunDrawUser
     return i18n ("Click to draw dots or drag to draw strokes.");
 }
 
-kpToolPenCommand *kpToolBrush::newCommand () const
-{
-    return new kpToolPenCommand (i18n ("Brush"), mainWindow ());
-}
-
 
 #include <kptoolbrush.moc>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolbrush.h head/kolourpaint/tools/kptoolbrush.h
--- base/kolourpaint/tools/kptoolbrush.h	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolbrush.h	2005-06-23 18:55:13.000000000 +1000
@@ -33,7 +33,8 @@
 #include <kptoolflowpixmapbase.h>
 
 
-class kpToolBrush : public kpToolDrawsPixmapsBase
+// Brush = draws pixmaps, "interpolates" by "sweeping" pixmaps along a line (interesting brushes)
+class kpToolBrush : public kpToolFlowPixmapBase
 {
 Q_OBJECT
 
@@ -44,7 +45,6 @@ public:
 
 protected:
     virtual QString haventBegunDrawUserMessage () const;
-    virtual kpToolPenCommand *newCommand () const;
     virtual bool haveDiverseBrushes () const { return true; }
 };
 
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolcolorwasher.cpp head/kolourpaint/tools/kptoolcolorwasher.cpp
--- base/kolourpaint/tools/kptoolcolorwasher.cpp	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolcolorwasher.cpp	2005-06-23 19:14:08.381390024 +1000
@@ -37,18 +37,19 @@
 
 #include <kapplication.h>
 #include <klocale.h>
-#include <kpdocument.h>
-#include <kppixmapfx.h>
 
 #include <kpcolor.h>
+#include <kpdocument.h>
+#include <kppixmapfx.h>
+#include <kptoolflowcommand.h>
 
 
 kpToolColorWasher::kpToolColorWasher (kpMainWindow *mainWindow)
-    : kpToolPen (kpToolPen::ColorWasher,
-                 i18n ("Color Eraser"),
-                 i18n ("Replaces pixels of the foreground color with the background color"),
-                 Qt::Key_O,
-                 mainWindow, "tool_color_washer")
+    : kpToolFlowBase (i18n ("Color Eraser"),
+        i18n ("Replaces pixels of the foreground color with the background color"),
+        Qt::Key_O,
+        mainWindow,
+        "tool_color_washer")
 {
 }
 
@@ -68,7 +69,7 @@ void kpToolColorWasher::globalDraw ()
 
     QApplication::setOverrideCursor (Qt::waitCursor);
 
-    kpToolPenCommand *cmd = new kpToolPenCommand (
+    kpToolFlowCommand *cmd = new kpToolFlowCommand (
         i18n ("Color Eraser"), mainWindow ());
 
     QPainter painter, maskPainter;
@@ -137,11 +138,6 @@ QString kpToolColorWasher::haventBegunDr
     return i18n ("Click or drag to erase pixels of the foreground color.");
 }
 
-kpToolPenCommand *kpToolColorWasher::newCommand () const
-{
-    return new kpToolPenCommand (i18n ("Color Eraser"), mainWindow ());
-}
-
 
 
 bool kpToolColorWasher::wash (QPainter *painter, QPainter *maskPainter,
@@ -358,12 +354,11 @@ bool kpToolColorWasher::drawLine (QPixma
     }
 
 
-    if (!didSomething)
-        maskBitmap = QBitmap ();
-        
+    
     drawLineTearDownPainterMask (pixmap,
         &maskBitmap,
-        &painter, &maskPainter);
+        &painter, &maskPainter,
+        didSomething);
 
 
 #if DEBUG_KP_TOOL_COLOR_WASHER
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolcolorwasher.h head/kolourpaint/tools/kptoolcolorwasher.h
--- base/kolourpaint/tools/kptoolcolorwasher.h	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolcolorwasher.h	2005-06-23 18:55:57.000000000 +1000
@@ -30,10 +30,11 @@
 #define KP_TOOL_COLOR_WASHER_H
 
 
-#include <kptoolpen.h>
+#include <kptoolflowbase.h>
 
 
-class kpToolColorWasher : public kpToolPen
+// Color Washer = Brush that replaces/washes the foreground color with the background color
+class kpToolColorWasher : public kpToolFlowBase
 {
 Q_OBJECT
 
@@ -58,7 +59,6 @@ public:
 
 protected:
     virtual QString haventBegunDrawUserMessage () const;
-    virtual kpToolPenCommand *newCommand () const;
     
     virtual bool drawShouldProceed (const QPoint &thisPoint,
         const QPoint &lastPoint,
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptooleraser.cpp head/kolourpaint/tools/kptooleraser.cpp
--- base/kolourpaint/tools/kptooleraser.cpp	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptooleraser.cpp	2005-06-23 18:58:00.844477992 +1000
@@ -38,10 +38,10 @@
 
 
 kpToolEraser::kpToolEraser (kpMainWindow *mainWindow)
-    : kpToolDrawsPixmapsBase (kpToolPen::Eraser,
-                 i18n ("Eraser"), i18n ("Lets you rub out mistakes"),
-                 Qt::Key_A,
-                 mainWindow, "tool_eraser")
+    : kpToolFlowPixmapBase (i18n ("Eraser"),
+        i18n ("Lets you rub out mistakes"),
+        Qt::Key_A,
+        mainWindow, "tool_eraser")
 {
 }
 
@@ -67,10 +67,5 @@ QString kpToolEraser::haventBegunDrawUse
     return i18n ("Click or drag to erase.");
 }
 
-kpToolPenCommand *kpToolEraser::newCommand () const
-{
-    return new kpToolPenCommand (i18n ("Eraser"), mainWindow ());
-}
-
 
 #include <kptooleraser.moc>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptooleraser.h head/kolourpaint/tools/kptooleraser.h
--- base/kolourpaint/tools/kptooleraser.h	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptooleraser.h	2005-06-23 18:57:33.000000000 +1000
@@ -33,7 +33,8 @@
 #include <kptoolflowpixmapbase.h>
 
 
-class kpToolEraser : public kpToolDrawsPixmapsBase
+// Eraser = Brush but with foreground & background colors swapped (a few square brushes)
+class kpToolEraser : public kpToolFlowPixmapBase
 {
 Q_OBJECT
 
@@ -49,7 +50,6 @@ public:
 
 protected:
     virtual QString haventBegunDrawUserMessage () const;
-    virtual kpToolPenCommand *newCommand () const;
     
     virtual bool haveSquareBrushes () const { return true; }
     virtual bool colorsAreSwapped () const { return true; }
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowbase.cpp head/kolourpaint/tools/kptoolflowbase.cpp
--- base/kolourpaint/tools/kptoolflowbase.cpp	1970-01-01 10:00:00.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowbase.cpp	2005-06-23 19:15:14.531333704 +1000
@@ -0,0 +1,558 @@
+
+/*
+   Copyright (c) 2003,2004,2005 Clarence Dang <dang@kde.org>
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#define DEBUG_KP_TOOL_FLOW_BASE 0
+
+#include <kptoolflowbase.h>
+
+#include <qapplication.h>
+#include <qbitmap.h>
+#include <qcursor.h>
+#include <qimage.h>
+#include <qpainter.h>
+#if DEBUG_KP_TOOL_FLOW_BASE
+    #include <qdatetime.h>
+#endif
+
+#include <kdebug.h>
+#include <klocale.h>
+
+#include <kpcolor.h>
+#include <kpcommandhistory.h>
+#include <kpcursorprovider.h>
+#include <kpdefs.h>
+#include <kpdocument.h>
+#include <kpmainwindow.h>
+#include <kppixmapfx.h>
+#include <kptemppixmap.h>
+#include <kptoolclear.h>
+#include <kptoolflowcommand.h>
+#include <kptooltoolbar.h>
+#include <kptoolwidgetbrush.h>
+#include <kptoolwidgeterasersize.h>
+#include <kpviewmanager.h>
+
+
+kpToolFlowBase::kpToolFlowBase (const QString &text, const QString &description,
+        int key,
+        kpMainWindow *mainWindow, const char *name)
+    : kpTool (text, description, key, mainWindow, name),
+      m_toolWidgetBrush (0),
+      m_toolWidgetEraserSize (0),
+      m_currentCommand (0)
+{
+}
+
+kpToolFlowBase::~kpToolFlowBase ()
+{
+}
+
+
+// virtual
+void kpToolFlowBase::begin ()
+{
+    m_toolWidgetBrush = 0;
+    m_brushIsDiagonalLine = false;
+
+    kpToolToolBar *tb = toolToolBar ();
+    if (!tb)
+        return;
+
+    if (haveSquareBrushes ())
+    {
+        m_toolWidgetEraserSize = tb->toolWidgetEraserSize ();
+        connect (m_toolWidgetEraserSize, SIGNAL (eraserSizeChanged (int)),
+                 this, SLOT (slotEraserSizeChanged (int)));
+        m_toolWidgetEraserSize->show ();
+
+        slotEraserSizeChanged (m_toolWidgetEraserSize->eraserSize ());
+
+        viewManager ()->setCursor (kpCursorProvider::lightCross ());
+    }
+
+    if (haveDiverseBrushes ())
+    {
+        m_toolWidgetBrush = tb->toolWidgetBrush ();
+        connect (m_toolWidgetBrush, SIGNAL (brushChanged (const QPixmap &, bool)),
+                 this, SLOT (slotBrushChanged (const QPixmap &, bool)));
+        m_toolWidgetBrush->show ();
+
+        slotBrushChanged (m_toolWidgetBrush->brush (),
+                          m_toolWidgetBrush->brushIsDiagonalLine ());
+
+        viewManager ()->setCursor (kpCursorProvider::lightCross ());
+    }
+
+    setUserMessage (haventBegunDrawUserMessage ());
+}
+
+// virtual
+void kpToolFlowBase::end ()
+{
+    if (m_toolWidgetEraserSize)
+    {
+        disconnect (m_toolWidgetEraserSize, SIGNAL (eraserSizeChanged (int)),
+                    this, SLOT (slotEraserSizeChanged (int)));
+        m_toolWidgetEraserSize = 0;
+    }
+
+    if (m_toolWidgetBrush)
+    {
+        disconnect (m_toolWidgetBrush, SIGNAL (brushChanged (const QPixmap &, bool)),
+                    this, SLOT (slotBrushChanged (const QPixmap &, bool)));
+        m_toolWidgetBrush = 0;
+    }
+
+    kpViewManager *vm = viewManager ();
+    if (vm)
+    {
+        if (vm->tempPixmap () && vm->tempPixmap ()->isBrush ())
+            vm->invalidateTempPixmap ();
+
+        if (haveAnyBrushes ())
+            vm->unsetCursor ();
+    }
+
+    // save memory
+    for (int i = 0; i < 2; i++)
+        m_brushPixmap [i].resize (0, 0);
+    m_cursorPixmap.resize (0, 0);
+}
+
+// virtual
+void kpToolFlowBase::beginDraw ()
+{
+    m_currentCommand = new kpToolFlowCommand (text (), mainWindow ());
+
+    // we normally show the Brush pix in the foreground colour but if the
+    // user starts drawing in the background color, we don't want to leave
+    // the cursor in the foreground colour -- just hide it in all cases
+    // to avoid confusion
+    viewManager ()->invalidateTempPixmap ();
+
+    setUserMessage (cancelUserMessage ());
+}
+
+// virtual
+void kpToolFlowBase::hover (const QPoint &point)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE && 0
+    kdDebug () << "kpToolFlowBase::hover(" << point << ")"
+               << " hasBegun=" << hasBegun ()
+               << " hasBegunDraw=" << hasBegunDraw ()
+               << " cursorPixmap.isNull=" << m_cursorPixmap.isNull ()
+               << endl;
+#endif
+    if (point != KP_INVALID_POINT && !m_cursorPixmap.isNull ())
+    {
+        m_mouseButton = 0;
+
+        kpTempPixmap::RenderMode renderMode;
+        QPixmap cursorPixmapForTempPixmap = m_cursorPixmap;
+
+        if (haveSquareBrushes ())
+            renderMode = kpTempPixmap::SetPixmap;
+        else if (haveDiverseBrushes ())
+        {
+            if (color (0).isOpaque ())
+                renderMode = kpTempPixmap::PaintPixmap;
+            else
+            {
+                renderMode = kpTempPixmap::PaintMaskTransparentWithBrush;
+                cursorPixmapForTempPixmap = kpPixmapFX::getNonNullMask (m_cursorPixmap);
+            }
+        }
+
+        viewManager ()->setFastUpdates ();
+
+        viewManager ()->setTempPixmap (
+            kpTempPixmap (true/*brush*/,
+                          renderMode,
+                          hotPoint (),
+                          cursorPixmapForTempPixmap));
+
+        viewManager ()->restoreFastUpdates ();
+    }
+
+#if DEBUG_KP_TOOL_FLOW_BASE && 0
+    if (document ()->rect ().contains (point))
+    {
+        QImage image = kpPixmapFX::convertToImage (*document ()->pixmap ());
+
+        QRgb v = image.pixel (point.x (), point.y ());
+        kdDebug () << "(" << point << "): r=" << qRed (v)
+                    << " g=" << qGreen (v)
+                    << " b=" << qBlue (v)
+                    << " a=" << qAlpha (v)
+                    << endl;
+    }
+#endif
+
+    setUserShapePoints (point);
+}
+
+QValueVector <QPoint> kpToolFlowBase::interpolatePoints (const QRect &rect/*TODO:take me away*/,
+    const QPoint &thisPoint, const QPoint &lastPoint)
+{
+    QValueVector <QPoint> ret;
+    
+    // Sweeps a pixmap along a line (modified Bresenham's line algorithm,
+    // see MODIFIED comment below).
+    //
+    // Derived from the zSprite2 Graphics Engine
+
+    const int x1 = (thisPoint - rect.topLeft ()).x (),
+                y1 = (thisPoint - rect.topLeft ()).y (),
+                x2 = (lastPoint - rect.topLeft ()).x (),
+                y2 = (lastPoint - rect.topLeft ()).y ();
+
+    // Difference of x and y values
+    int dx = x2 - x1;
+    int dy = y2 - y1;
+
+    // Absolute values of differences
+    int ix = kAbs (dx);
+    int iy = kAbs (dy);
+
+    // Larger of the x and y differences
+    int inc = ix > iy ? ix : iy;
+
+    // Plot location
+    int plotx = x1;
+    int ploty = y1;
+
+    int x = 0;
+    int y = 0;
+
+    ret.append (QPoint (plotx, ploty));
+    
+    
+    for (int i = 0; i <= inc; i++)
+    {
+        // oldplotx is equally as valid but would look different
+        // (but nobody will notice which one it is)
+        int oldploty = ploty;
+        int plot = 0;
+
+        x += ix;
+        y += iy;
+
+        if (x > inc)
+        {
+            plot++;
+            x -= inc;
+
+            if (dx < 0)
+                plotx--;
+            else
+                plotx++;
+        }
+
+        if (y > inc)
+        {
+            plot++;
+            y -= inc;
+
+            if (dy < 0)
+                ploty--;
+            else
+                ploty++;
+        }
+
+        if (plot)
+        {
+            if (m_brushIsDiagonalLine && plot == 2)
+            {
+                // MODIFIED: every point is
+                // horizontally or vertically adjacent to another point (if there
+                // is more than 1 point, of course).  This is in contrast to the
+                // ordinary line algorithm which can create diagonal adjacencies.
+
+                ret.append (QPoint (plotx, oldploty));
+            }
+
+            ret.append (QPoint (plotx, ploty));
+        }    
+    }
+    
+    return ret;
+}
+
+
+void kpToolFlowBase::drawLineSetupPainterMask (QPixmap *pixmap,
+    QBitmap *maskBitmap,
+    QPainter *painter, QPainter *maskPainter)
+{
+    const kpColor col = color (m_mouseButton);
+
+    if (!col.isTransparent ())
+    {
+        painter->begin (pixmap);
+        painter->setPen (col.toQColor ());
+    }
+
+    if (col.isTransparent () || pixmap->mask ())
+    {
+        *maskBitmap = kpPixmapFX::getNonNullMask (*pixmap);
+        maskPainter->begin (maskBitmap);
+        maskPainter->setPen (col.maskColor ());
+    }
+}
+
+void kpToolFlowBase::drawLineTearDownPainterMask (QPixmap *pixmap,
+    const QBitmap *maskBitmap,
+    QPainter *painter, QPainter *maskPainter,
+    bool drawingHappened)
+{        
+    if (painter->isActive ())
+        painter->end ();
+
+    if (maskPainter->isActive ())
+        maskPainter->end ();
+
+
+
+    if (drawingHappened)
+    {
+        if (!maskBitmap->isNull ())
+            pixmap->setMask (*maskBitmap);
+    }
+}
+
+        
+
+
+// virtual
+void kpToolFlowBase::draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &normalizedRect)
+{
+    if (!drawShouldProceed (thisPoint, lastPoint, normalizedRect))
+        return;
+
+    // sync: remember to restoreFastUpdates() in all exit paths
+    viewManager ()->setFastUpdates ();
+
+    if (m_brushIsDiagonalLine ?
+            currentPointCardinallyNextToLast () :
+            currentPointNextToLast ())
+    {
+        drawPoint (thisPoint);
+    }
+    // in reality, the system is too slow to give us all the MouseMove events
+    // so we "interpolate" the missing points :)
+    else
+    {
+        QRect rect = QRect (thisPoint, lastPoint).normalize ();
+        rect = neededRect (rect, m_brushPixmap [m_mouseButton].width ());
+    
+        QPixmap pixmap = document ()->getPixmapAt (rect);
+
+        if (drawLine (&pixmap, rect, thisPoint, lastPoint))
+        {
+            document ()->setPixmapAt (pixmap, rect.topLeft ());
+
+            m_currentCommand->updateBoundingRect (rect);
+        }        
+    }
+
+    viewManager ()->restoreFastUpdates ();
+    setUserShapePoints (thisPoint);
+}
+
+// virtual
+void kpToolFlowBase::cancelShape ()
+{
+    m_currentCommand->finalize ();
+    m_currentCommand->cancel ();
+
+    delete m_currentCommand;
+    m_currentCommand = 0;
+
+    updateBrushCursor (false/*no recalc*/);
+
+    setUserMessage (i18n ("Let go of all the mouse buttons."));
+}
+
+void kpToolFlowBase::releasedAllButtons ()
+{
+    setUserMessage (haventBegunDrawUserMessage ());
+}
+
+// virtual
+void kpToolFlowBase::endDraw (const QPoint &, const QRect &)
+{
+    m_currentCommand->finalize ();
+    mainWindow ()->commandHistory ()->addCommand (m_currentCommand, false /* don't exec */);
+
+    // don't delete - it's up to the commandHistory
+    m_currentCommand = 0;
+
+    updateBrushCursor (false/*no recalc*/);
+
+    setUserMessage (haventBegunDrawUserMessage ());
+}
+
+
+// TODO: maybe the base should be virtual?
+kpColor kpToolFlowBase::color (int which)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE && 0
+    kdDebug () << "kpToolFlowBase::color (" << which << ")" << endl;
+#endif
+
+    // Pen & Brush
+    if (!colorsAreSwapped ())
+        return kpTool::color (which);
+    // only the (Color) Eraser uses the opposite color
+    else
+        return kpTool::color (which ? 0 : 1);  // don't trust !0 == 1
+}
+
+// virtual private slot
+void kpToolFlowBase::slotForegroundColorChanged (const kpColor &col)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE
+    kdDebug () << "kpToolFlowBase::slotForegroundColorChanged()" << endl;
+#endif
+    if (col.isOpaque ())
+        m_brushPixmap [colorsAreSwapped () ? 1 : 0].fill (col.toQColor ());
+
+    updateBrushCursor ();
+}
+
+// virtual private slot
+void kpToolFlowBase::slotBackgroundColorChanged (const kpColor &col)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE
+    kdDebug () << "kpToolFlowBase::slotBackgroundColorChanged()" << endl;
+#endif
+
+    if (col.isOpaque ())
+        m_brushPixmap [colorsAreSwapped () ? 0 : 1].fill (col.toQColor ());
+
+    updateBrushCursor ();
+}
+
+// private slot
+void kpToolFlowBase::slotBrushChanged (const QPixmap &pixmap, bool isDiagonalLine)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE
+    kdDebug () << "kpToolFlowBase::slotBrushChanged()" << endl;
+#endif
+    for (int i = 0; i < 2; i++)
+    {
+        m_brushPixmap [i] = pixmap;
+        if (color (i).isOpaque ())
+            m_brushPixmap [i].fill (color (i).toQColor ());
+    }
+
+    m_brushIsDiagonalLine = isDiagonalLine;
+
+    updateBrushCursor ();
+}
+
+// private slot
+void kpToolFlowBase::slotEraserSizeChanged (int size)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE
+    kdDebug () << "KpToolFlowBase::slotEraserSizeChanged(size=" << size << ")" << endl;
+#endif
+
+    for (int i = 0; i < 2; i++)
+    {
+        m_brushPixmap [i].resize (size, size);
+        if (color (i).isOpaque ())
+            m_brushPixmap [i].fill (color (i).toQColor ());
+    }
+
+    updateBrushCursor ();
+}
+
+QPoint kpToolFlowBase::hotPoint () const
+{
+    return hotPoint (m_currentPoint);
+}
+
+QPoint kpToolFlowBase::hotPoint (int x, int y) const
+{
+    return hotPoint (QPoint (x, y));
+}
+
+QPoint kpToolFlowBase::hotPoint (const QPoint &point) const
+{
+    /*
+     * e.g.
+     *    Width 5:
+     *    0 1 2 3 4
+     *        ^
+     *        |
+     *      Center
+     */
+    return point -
+           QPoint (m_brushPixmap [m_mouseButton].width () / 2,
+                   m_brushPixmap [m_mouseButton].height () / 2);
+}
+
+QRect kpToolFlowBase::hotRect () const
+{
+    return hotRect (m_currentPoint);
+}
+
+QRect kpToolFlowBase::hotRect (int x, int y) const
+{
+    return hotRect (QPoint (x, y));
+}
+
+QRect kpToolFlowBase::hotRect (const QPoint &point) const
+{
+    QPoint topLeft = hotPoint (point);
+    return QRect (topLeft.x (),
+                  topLeft.y (),
+                  m_brushPixmap [m_mouseButton].width (),
+                  m_brushPixmap [m_mouseButton].height ());
+}
+
+// private
+void kpToolFlowBase::updateBrushCursor (bool recalc)
+{
+#if DEBUG_KP_TOOL_FLOW_BASE && 1
+    kdDebug () << "kpToolFlowBase::updateBrushCursor(recalc=" << recalc << ")" << endl;
+#endif
+
+    if (recalc)
+    {
+        if (haveSquareBrushes ())
+            m_cursorPixmap = m_toolWidgetEraserSize->cursorPixmap (color (0));
+        else if (haveDiverseBrushes ())
+            m_cursorPixmap = m_brushPixmap [0];
+    }
+
+    hover (hasBegun () ? m_currentPoint : currentPoint ());
+}
+
+
+#include <kptoolflowbase.moc>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowbase.h head/kolourpaint/tools/kptoolflowbase.h
--- base/kolourpaint/tools/kptoolflowbase.h	1970-01-01 10:00:00.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowbase.h	2005-06-23 19:15:16.151087464 +1000
@@ -0,0 +1,131 @@
+
+/*
+   Copyright (c) 2003,2004,2005 Clarence Dang <dang@kde.org>
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef KP_TOOL_FLOW_BASE_H
+#define KP_TOOL_FLOW_BASE_H
+
+
+#include <qpixmap.h>
+#include <qrect.h>
+#include <qvaluevector.h>
+
+#include <kpcommandhistory.h>
+#include <kptool.h>
+
+
+class QPoint;
+class QString;
+
+class kpColor;
+class kpMainWindow;
+class kpToolFlowCommand;
+class kpToolWidgetBrush;
+class kpToolWidgetEraserSize;
+class kpViewManager;
+
+
+class kpToolFlowBase : public kpTool
+{
+Q_OBJECT
+
+public:
+    kpToolFlowBase (const QString &text, const QString &description,
+        int key,
+        kpMainWindow *mainWindow, const char *name);
+    virtual ~kpToolFlowBase ();
+
+protected:
+    virtual QString haventBegunDrawUserMessage () const = 0;
+    
+    virtual bool haveSquareBrushes () const { return false; }
+    virtual bool haveDiverseBrushes () const { return false; }    
+    bool haveAnyBrushes () const
+    {
+        return (haveSquareBrushes () || haveDiverseBrushes ());
+    }
+    
+    virtual bool colorsAreSwapped () const { return false; }
+    
+public:
+    virtual void begin ();
+    virtual void end ();
+
+    virtual void beginDraw ();
+    virtual void hover (const QPoint &point);
+    
+    QValueVector <QPoint> interpolatePoints (const QRect &rect/*TODO:take me away*/,
+        const QPoint &thisPoint, const QPoint &lastPoint);
+
+    virtual void drawPoint (const QPoint &point) = 0;
+    
+    void drawLineSetupPainterMask (QPixmap *pixmap,
+        QBitmap *maskBitmap,
+        QPainter *painter, QPainter *maskPainter);
+    void drawLineTearDownPainterMask (QPixmap *pixmap,
+        const QBitmap *maskBitmap,
+        QPainter *painter, QPainter *maskPainter,
+        bool drawingHappened = true);
+        
+    virtual bool drawLine (QPixmap *pixmap, const QRect &docRect,
+        const QPoint &thisPoint, const QPoint &lastPoint) = 0;
+
+    virtual bool drawShouldProceed (const QPoint & /*thisPoint*/, const QPoint & /*lastPoint*/, const QRect & /*normalizedRect*/) { return true; }
+    virtual void draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &normalizedRect);
+    virtual void cancelShape ();
+    virtual void releasedAllButtons ();
+    virtual void endDraw (const QPoint &, const QRect &);
+
+protected slots:
+    virtual void slotForegroundColorChanged (const kpColor &col);
+    virtual void slotBackgroundColorChanged (const kpColor &col);
+
+    void slotBrushChanged (const QPixmap &pixmap, bool isDiagonalLine);
+    void slotEraserSizeChanged (int size);
+
+protected:
+    virtual kpColor color (int which);
+
+    QPoint hotPoint () const;
+    QPoint hotPoint (int x, int y) const;
+    QPoint hotPoint (const QPoint &point) const;
+    QRect hotRect () const;
+    QRect hotRect (int x, int y) const;
+    QRect hotRect (const QPoint &point) const;
+
+    void updateBrushCursor (bool recalc = true);
+
+    kpToolWidgetBrush *m_toolWidgetBrush;
+    kpToolWidgetEraserSize *m_toolWidgetEraserSize;
+    QPixmap m_brushPixmap [2];
+    QPixmap m_cursorPixmap;
+    bool m_brushIsDiagonalLine;
+
+    kpToolFlowCommand *m_currentCommand;
+};
+
+#endif  // KP_TOOL_FLOW_BASE_H
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowcommand.cpp head/kolourpaint/tools/kptoolflowcommand.cpp
--- base/kolourpaint/tools/kptoolflowcommand.cpp	1970-01-01 10:00:00.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowcommand.cpp	2005-06-23 18:40:15.000000000 +1000
@@ -0,0 +1,141 @@
+
+/*
+   Copyright (c) 2003,2004,2005 Clarence Dang <dang@kde.org>
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#define DEBUG_KP_TOOL_FLOW_COMMAND 0
+
+
+#include <kptoolflowcommand.h>
+
+#include <qpixmap.h>
+#include <qrect.h>
+
+#include <kpdocument.h>
+#include <kppixmapfx.h>
+#include <kptool.h>
+#include <kpviewmanager.h>
+
+
+struct kpToolFlowCommandPrivate
+{
+    QPixmap m_pixmap;
+    QRect m_boundingRect;
+};
+
+
+kpToolFlowCommand::kpToolFlowCommand (const QString &name, kpMainWindow *mainWindow)
+    : kpNamedCommand (name, mainWindow),
+      d (new kpToolFlowCommandPrivate ())
+{
+    d->m_pixmap = *document ()->pixmap ();
+}
+
+kpToolFlowCommand::~kpToolFlowCommand ()
+{
+    delete d;
+}
+
+
+// public virtual [base kpCommand]
+int kpToolFlowCommand::size () const
+{
+    return kpPixmapFX::pixmapSize (d->m_pixmap);
+}
+
+
+// public virtual [base kpCommand]
+void kpToolFlowCommand::execute ()
+{
+    swapOldAndNew ();
+}
+
+// public virtual [base kpCommand]
+void kpToolFlowCommand::unexecute ()
+{
+    swapOldAndNew ();
+}
+
+
+// private
+void kpToolFlowCommand::swapOldAndNew ()
+{
+    if (d->m_boundingRect.isValid ())
+    {
+        QPixmap oldPixmap = document ()->getPixmapAt (d->m_boundingRect);
+
+        document ()->setPixmapAt (d->m_pixmap, d->m_boundingRect.topLeft ());
+
+        d->m_pixmap = oldPixmap;
+    }
+}
+
+// public
+void kpToolFlowCommand::updateBoundingRect (const QPoint &point)
+{
+    updateBoundingRect (QRect (point, point));
+}
+
+// public
+void kpToolFlowCommand::updateBoundingRect (const QRect &rect)
+{
+#if DEBUG_KP_TOOL_FLOW_COMMAND & 0
+    kdDebug () << "kpToolFlowCommand::updateBoundingRect()  existing="
+               << d->m_boundingRect
+               << " plus="
+               << rect
+               << endl;
+#endif
+    d->m_boundingRect = d->m_boundingRect.unite (rect);
+#if DEBUG_KP_TOOL_FLOW_COMMAND & 0
+    kdDebug () << "\tresult=" << d->m_boundingRect << endl;
+#endif
+}
+
+// public
+void kpToolFlowCommand::finalize ()
+{
+    if (d->m_boundingRect.isValid ())
+    {
+        // store only needed part of doc pixmap
+        d->m_pixmap = kpTool::neededPixmap (d->m_pixmap, d->m_boundingRect);
+    }
+    else
+    {
+        d->m_pixmap.resize (0, 0);
+    }
+}
+
+// public
+void kpToolFlowCommand::cancel ()
+{
+    if (d->m_boundingRect.isValid ())
+    {
+        viewManager ()->setFastUpdates ();
+        document ()->setPixmapAt (d->m_pixmap, d->m_boundingRect.topLeft ());
+        viewManager ()->restoreFastUpdates ();
+    }
+}
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowcommand.h head/kolourpaint/tools/kptoolflowcommand.h
--- base/kolourpaint/tools/kptoolflowcommand.h	1970-01-01 10:00:00.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowcommand.h	2005-06-23 18:40:09.000000000 +1000
@@ -0,0 +1,64 @@
+
+/*
+   Copyright (c) 2003,2004,2005 Clarence Dang <dang@kde.org>
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef KP_TOOL_FLOW_COMMAND_H
+#define KP_TOOL_FLOW_COMMAND_H
+
+
+#include <kpcommandhistory.h>
+
+
+class QPoint;
+class QRect;
+
+
+class kpToolFlowCommand : public kpNamedCommand
+{
+public:
+    kpToolFlowCommand (const QString &name, kpMainWindow *mainWindow);
+    virtual ~kpToolFlowCommand ();
+
+    virtual int size () const;
+    
+    virtual void execute ();
+    virtual void unexecute ();
+
+    // interface for kpToolFlowBase
+    void updateBoundingRect (const QPoint &point);
+    void updateBoundingRect (const QRect &rect);
+    void finalize ();
+    void cancel ();
+
+private:
+    void swapOldAndNew ();
+
+    struct kpToolFlowCommandPrivate *d;
+};
+
+
+#endif  // KP_TOOL_FLOW_COMMAND_H
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowpixmapbase.cpp head/kolourpaint/tools/kptoolflowpixmapbase.cpp
--- base/kolourpaint/tools/kptoolflowpixmapbase.cpp	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowpixmapbase.cpp	2005-06-23 19:03:13.253984528 +1000
@@ -33,20 +33,22 @@
 #include <kpcolor.h>
 #include <kpdocument.h>
 #include <kppixmapfx.h>
+#include <kptoolflowcommand.h>
 
-kpToolDrawsPixmapsBase::kpToolDrawsPixmapsBase (Mode mode, const QString &text, const QString &description,
+
+kpToolFlowPixmapBase::kpToolFlowPixmapBase (const QString &text, const QString &description,
             int key,
             kpMainWindow *mainWindow, const char *name)
-    : kpToolPen (mode, text, description, key, mainWindow, name)
+    : kpToolFlowBase (text, description, key, mainWindow, name)
 {
 }
 
-kpToolDrawsPixmapsBase::~kpToolDrawsPixmapsBase ()
+kpToolFlowPixmapBase::~kpToolFlowPixmapBase ()
 {
 }
 
 
-void kpToolDrawsPixmapsBase::drawPoint (const QPoint & /*point*/)
+void kpToolFlowPixmapBase::drawPoint (const QPoint & /*point*/)
 {            
     if (color (m_mouseButton).isOpaque ())
         document ()->paintPixmapAt (m_brushPixmap [m_mouseButton], hotPoint ());
@@ -63,7 +65,7 @@ void kpToolDrawsPixmapsBase::drawPoint (
 
 
 
-bool kpToolDrawsPixmapsBase::drawLine (QPixmap *pixmap,
+bool kpToolFlowPixmapBase::drawLine (QPixmap *pixmap,
     const QRect &docRect,
     const QPoint &thisPoint, const QPoint &lastPoint)
 {
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolflowpixmapbase.h head/kolourpaint/tools/kptoolflowpixmapbase.h
--- base/kolourpaint/tools/kptoolflowpixmapbase.h	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolflowpixmapbase.h	2005-06-23 18:59:32.095605712 +1000
@@ -26,11 +26,11 @@
 */
 
 
-#ifndef KP_TOOL_DRAWS_PIXMAPS_BASE
-#define KP_TOOL_DRAWS_PIXMAPS_BASE
+#ifndef KP_TOOL_FLOW_PIXMAP_BASE_H
+#define KP_TOOL_FLOW_PIXMAP_BASE_H
 
 
-#include <kptoolpen.h>
+#include <kptoolflowbase.h>
 
 
 /**
@@ -39,15 +39,15 @@
  *
  * @author Clarence Dang <dang@kde.org>
  */
-class kpToolDrawsPixmapsBase : public kpToolPen
+class kpToolFlowPixmapBase : public kpToolFlowBase
 {
 Q_OBJECT
 
 public:
-    kpToolDrawsPixmapsBase (Mode mode, const QString &text, const QString &description,
+    kpToolFlowPixmapBase (const QString &text, const QString &description,
                int key,
                kpMainWindow *mainWindow, const char *name);
-    virtual ~kpToolDrawsPixmapsBase ();
+    virtual ~kpToolFlowPixmapBase ();
     
 protected:
     virtual void drawPoint (const QPoint &point);
@@ -59,4 +59,4 @@ protected:
 };
 
 
-#endif  // KP_TOOL_DRAWS_PIXMAPS_BASE
+#endif  // KP_TOOL_FLOW_PIXMAP_BASE_H
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolpen.cpp head/kolourpaint/tools/kptoolpen.cpp
--- base/kolourpaint/tools/kptoolpen.cpp	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolpen.cpp	2005-06-23 19:06:12.000000000 +1000
@@ -26,75 +26,23 @@
 */
 
 
-#define DEBUG_KP_TOOL_PEN 0
+#include <kptoolpen.h>
 
-#include <qapplication.h>
 #include <qbitmap.h>
-#include <qcursor.h>
-#include <qimage.h>
 #include <qpainter.h>
-#if DEBUG_KP_TOOL_PEN
-    #include <qdatetime.h>
-#endif
 
-#include <kdebug.h>
 #include <klocale.h>
 
 #include <kpcolor.h>
-#include <kpcommandhistory.h>
-#include <kpcursorprovider.h>
-#include <kptoolpen.h>
-#include <kpdefs.h>
 #include <kpdocument.h>
-#include <kpmainwindow.h>
-#include <kppixmapfx.h>
-#include <kptemppixmap.h>
-#include <kptoolclear.h>
-#include <kptooltoolbar.h>
-#include <kptoolwidgetbrush.h>
-#include <kptoolwidgeterasersize.h>
-#include <kpviewmanager.h>
-
-/*
- * kpToolPen
- */
+#include <kptoolflowcommand.h>
 
-kpToolPen::kpToolPen (Mode mode,
-                      const QString &text, const QString &description,
-                      int key,
-                      kpMainWindow *mainWindow, const char *name)
-    : kpTool (text, description, key, mainWindow, name),
-      m_mode (mode),
-      m_toolWidgetBrush (0),
-      m_toolWidgetEraserSize (0),
-      m_currentCommand (0)
-{
-}
 
 kpToolPen::kpToolPen (kpMainWindow *mainWindow)
-    : kpTool (i18n ("Pen"), i18n ("Draws dots and freehand strokes"),
-              Qt::Key_P,
-              mainWindow, "tool_pen"),
-      m_mode (Pen),
-      m_toolWidgetBrush (0),
-      m_toolWidgetEraserSize (0),
-      m_currentCommand (0)
-{
-}
-
-void kpToolPen::setMode (Mode mode)
+    : kpToolFlowBase (i18n ("Pen"), i18n ("Draws dots and freehand strokes"),
+        Qt::Key_P,
+        mainWindow, "tool_pen")
 {
-    int usesPixmaps = (mode & (DrawsPixmaps | WashesPixmaps));
-    int usesBrushes = (mode & (SquareBrushes | DiverseBrushes));
-
-    if ((usesPixmaps && !usesBrushes) ||
-        (usesBrushes && !usesPixmaps))
-    {
-        kdError () << "kpToolPen::setMode() passed invalid mode" << endl;
-        return;
-    }
-
-    m_mode = mode;
 }
 
 kpToolPen::~kpToolPen ()
@@ -108,154 +56,6 @@ QString kpToolPen::haventBegunDrawUserMe
     return i18n ("Click to draw dots or drag to draw strokes.");
 }
 
-// virtual
-void kpToolPen::begin ()
-{
-    m_toolWidgetBrush = 0;
-    m_brushIsDiagonalLine = false;
-
-    kpToolToolBar *tb = toolToolBar ();
-    if (!tb)
-        return;
-
-    if (haveSquareBrushes ())
-    {
-        m_toolWidgetEraserSize = tb->toolWidgetEraserSize ();
-        connect (m_toolWidgetEraserSize, SIGNAL (eraserSizeChanged (int)),
-                 this, SLOT (slotEraserSizeChanged (int)));
-        m_toolWidgetEraserSize->show ();
-
-        slotEraserSizeChanged (m_toolWidgetEraserSize->eraserSize ());
-
-        viewManager ()->setCursor (kpCursorProvider::lightCross ());
-    }
-
-    if (haveDiverseBrushes ())
-    {
-        m_toolWidgetBrush = tb->toolWidgetBrush ();
-        connect (m_toolWidgetBrush, SIGNAL (brushChanged (const QPixmap &, bool)),
-                 this, SLOT (slotBrushChanged (const QPixmap &, bool)));
-        m_toolWidgetBrush->show ();
-
-        slotBrushChanged (m_toolWidgetBrush->brush (),
-                          m_toolWidgetBrush->brushIsDiagonalLine ());
-
-        viewManager ()->setCursor (kpCursorProvider::lightCross ());
-    }
-
-    setUserMessage (haventBegunDrawUserMessage ());
-}
-
-// virtual
-void kpToolPen::end ()
-{
-    if (m_toolWidgetEraserSize)
-    {
-        disconnect (m_toolWidgetEraserSize, SIGNAL (eraserSizeChanged (int)),
-                    this, SLOT (slotEraserSizeChanged (int)));
-        m_toolWidgetEraserSize = 0;
-    }
-
-    if (m_toolWidgetBrush)
-    {
-        disconnect (m_toolWidgetBrush, SIGNAL (brushChanged (const QPixmap &, bool)),
-                    this, SLOT (slotBrushChanged (const QPixmap &, bool)));
-        m_toolWidgetBrush = 0;
-    }
-
-    kpViewManager *vm = viewManager ();
-    if (vm)
-    {
-        if (vm->tempPixmap () && vm->tempPixmap ()->isBrush ())
-            vm->invalidateTempPixmap ();
-
-        if (haveAnyBrushes ())
-            vm->unsetCursor ();
-    }
-
-    // save memory
-    for (int i = 0; i < 2; i++)
-        m_brushPixmap [i].resize (0, 0);
-    m_cursorPixmap.resize (0, 0);
-}
-
-kpToolPenCommand *kpToolPen::newCommand () const
-{
-    return new kpToolPenCommand (i18n ("Pen"), mainWindow ());
-}
-
-
-// virtual
-void kpToolPen::beginDraw ()
-{
-    m_currentCommand = newCommand ();
-
-    // we normally show the Brush pix in the foreground colour but if the
-    // user starts drawing in the background color, we don't want to leave
-    // the cursor in the foreground colour -- just hide it in all cases
-    // to avoid confusion
-    viewManager ()->invalidateTempPixmap ();
-
-    setUserMessage (cancelUserMessage ());
-}
-
-// virtual
-void kpToolPen::hover (const QPoint &point)
-{
-#if DEBUG_KP_TOOL_PEN && 0
-    kdDebug () << "kpToolPen::hover(" << point << ")"
-               << " hasBegun=" << hasBegun ()
-               << " hasBegunDraw=" << hasBegunDraw ()
-               << " cursorPixmap.isNull=" << m_cursorPixmap.isNull ()
-               << endl;
-#endif
-    if (point != KP_INVALID_POINT && !m_cursorPixmap.isNull ())
-    {
-        m_mouseButton = 0;
-
-        kpTempPixmap::RenderMode renderMode;
-        QPixmap cursorPixmapForTempPixmap = m_cursorPixmap;
-
-        if (haveSquareBrushes ())
-            renderMode = kpTempPixmap::SetPixmap;
-        else if (haveDiverseBrushes ())
-        {
-            if (color (0).isOpaque ())
-                renderMode = kpTempPixmap::PaintPixmap;
-            else
-            {
-                renderMode = kpTempPixmap::PaintMaskTransparentWithBrush;
-                cursorPixmapForTempPixmap = kpPixmapFX::getNonNullMask (m_cursorPixmap);
-            }
-        }
-
-        viewManager ()->setFastUpdates ();
-
-        viewManager ()->setTempPixmap (
-            kpTempPixmap (true/*brush*/,
-                          renderMode,
-                          hotPoint (),
-                          cursorPixmapForTempPixmap));
-
-        viewManager ()->restoreFastUpdates ();
-    }
-
-#if DEBUG_KP_TOOL_PEN && 0
-    if (document ()->rect ().contains (point))
-    {
-        QImage image = kpPixmapFX::convertToImage (*document ()->pixmap ());
-
-        QRgb v = image.pixel (point.x (), point.y ());
-        kdDebug () << "(" << point << "): r=" << qRed (v)
-                    << " g=" << qGreen (v)
-                    << " b=" << qBlue (v)
-                    << " a=" << qAlpha (v)
-                    << endl;
-    }
-#endif
-
-    setUserShapePoints (point);
-}
 
 void kpToolPen::drawPoint (const QPoint &point)
 {
@@ -283,131 +83,7 @@ void kpToolPen::drawPoint (const QPoint 
 }
 
 
-QValueVector <QPoint> kpToolPen::interpolatePoints (const QRect &rect/*TODO:take me away*/,
-    const QPoint &thisPoint, const QPoint &lastPoint)
-{
-    QValueVector <QPoint> ret;
-    
-    // Sweeps a pixmap along a line (modified Bresenham's line algorithm,
-    // see MODIFIED comment below).
-    //
-    // Derived from the zSprite2 Graphics Engine
-
-    const int x1 = (thisPoint - rect.topLeft ()).x (),
-                y1 = (thisPoint - rect.topLeft ()).y (),
-                x2 = (lastPoint - rect.topLeft ()).x (),
-                y2 = (lastPoint - rect.topLeft ()).y ();
-
-    // Difference of x and y values
-    int dx = x2 - x1;
-    int dy = y2 - y1;
-
-    // Absolute values of differences
-    int ix = kAbs (dx);
-    int iy = kAbs (dy);
-
-    // Larger of the x and y differences
-    int inc = ix > iy ? ix : iy;
-
-    // Plot location
-    int plotx = x1;
-    int ploty = y1;
-
-    int x = 0;
-    int y = 0;
-
-    ret.append (QPoint (plotx, ploty));
-    
-    
-    for (int i = 0; i <= inc; i++)
-    {
-        // oldplotx is equally as valid but would look different
-        // (but nobody will notice which one it is)
-        int oldploty = ploty;
-        int plot = 0;
-
-        x += ix;
-        y += iy;
-
-        if (x > inc)
-        {
-            plot++;
-            x -= inc;
-
-            if (dx < 0)
-                plotx--;
-            else
-                plotx++;
-        }
-
-        if (y > inc)
-        {
-            plot++;
-            y -= inc;
-
-            if (dy < 0)
-                ploty--;
-            else
-                ploty++;
-        }
-
-        if (plot)
-        {
-            if (m_brushIsDiagonalLine && plot == 2)
-            {
-                // MODIFIED: every point is
-                // horizontally or vertically adjacent to another point (if there
-                // is more than 1 point, of course).  This is in contrast to the
-                // ordinary line algorithm which can create diagonal adjacencies.
-
-                ret.append (QPoint (plotx, oldploty));
-            }
-
-            ret.append (QPoint (plotx, ploty));
-        }    
-    }
-    
-    return ret;
-}
-
-
-void kpToolPen::drawLineSetupPainterMask (QPixmap *pixmap,
-    QBitmap *maskBitmap,
-    QPainter *painter, QPainter *maskPainter)
-{
-    const kpColor col = color (m_mouseButton);
-
-    if (!col.isTransparent ())
-    {
-        painter->begin (pixmap);
-        painter->setPen (col.toQColor ());
-    }
-
-    if (col.isTransparent () || pixmap->mask ())
-    {
-        *maskBitmap = kpPixmapFX::getNonNullMask (*pixmap);
-        maskPainter->begin (maskBitmap);
-        maskPainter->setPen (col.maskColor ());
-    }
-}
-
-void kpToolPen::drawLineTearDownPainterMask (QPixmap *pixmap,
-    const QBitmap *maskBitmap,
-    QPainter *painter, QPainter *maskPainter)
-{        
-    if (painter->isActive ())
-        painter->end ();
-
-    if (maskPainter->isActive ())
-        maskPainter->end ();
-
-
-
-    if (!maskBitmap->isNull ())
-        pixmap->setMask (*maskBitmap);
-}
 
-        
 bool kpToolPen::drawLine (QPixmap *pixmap, const QRect &docRect,
     const QPoint &thisPoint, const QPoint &lastPoint)
 {
@@ -438,310 +114,4 @@ bool kpToolPen::drawLine (QPixmap *pixma
 }
 
 
-
-
-// virtual
-// TODO: refactor!
-void kpToolPen::draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &normalizedRect)
-{
-    if (!drawShouldProceed (thisPoint, lastPoint, normalizedRect))
-        return;
-
-    // sync: remember to restoreFastUpdates() in all exit paths
-    viewManager ()->setFastUpdates ();
-
-    if (m_brushIsDiagonalLine ?
-            currentPointCardinallyNextToLast () :
-            currentPointNextToLast ())
-    {
-        drawPoint (thisPoint);
-    }
-    // in reality, the system is too slow to give us all the MouseMove events
-    // so we "interpolate" the missing points :)
-    else
-    {
-        QRect rect = QRect (thisPoint, lastPoint).normalize ();
-        rect = neededRect (rect, m_brushPixmap [m_mouseButton].width ());
-    
-        QPixmap pixmap = document ()->getPixmapAt (rect);
-
-        if (drawLine (&pixmap, rect, thisPoint, lastPoint))
-        {
-            document ()->setPixmapAt (pixmap, rect.topLeft ());
-
-            m_currentCommand->updateBoundingRect (rect);
-        }        
-    }
-
-    viewManager ()->restoreFastUpdates ();
-    setUserShapePoints (thisPoint);
-}
-
-// virtual
-void kpToolPen::cancelShape ()
-{
-    m_currentCommand->finalize ();
-    m_currentCommand->cancel ();
-
-    delete m_currentCommand;
-    m_currentCommand = 0;
-
-    updateBrushCursor (false/*no recalc*/);
-
-    setUserMessage (i18n ("Let go of all the mouse buttons."));
-}
-
-void kpToolPen::releasedAllButtons ()
-{
-    setUserMessage (haventBegunDrawUserMessage ());
-}
-
-// virtual
-void kpToolPen::endDraw (const QPoint &, const QRect &)
-{
-    m_currentCommand->finalize ();
-    mainWindow ()->commandHistory ()->addCommand (m_currentCommand, false /* don't exec */);
-
-    // don't delete - it's up to the commandHistory
-    m_currentCommand = 0;
-
-    updateBrushCursor (false/*no recalc*/);
-
-    setUserMessage (haventBegunDrawUserMessage ());
-}
-
-
-// TODO: maybe the base should be virtual?
-kpColor kpToolPen::color (int which)
-{
-#if DEBUG_KP_TOOL_PEN && 0
-    kdDebug () << "kpToolPen::color (" << which << ")" << endl;
-#endif
-
-    // Pen & Brush
-    if (!colorsAreSwapped ())
-        return kpTool::color (which);
-    // only the (Color) Eraser uses the opposite color
-    else
-        return kpTool::color (which ? 0 : 1);  // don't trust !0 == 1
-}
-
-// virtual private slot
-void kpToolPen::slotForegroundColorChanged (const kpColor &col)
-{
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "kpToolPen::slotForegroundColorChanged()" << endl;
-#endif
-    if (col.isOpaque ())
-        m_brushPixmap [colorsAreSwapped () ? 1 : 0].fill (col.toQColor ());
-
-    updateBrushCursor ();
-}
-
-// virtual private slot
-void kpToolPen::slotBackgroundColorChanged (const kpColor &col)
-{
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "kpToolPen::slotBackgroundColorChanged()" << endl;
-#endif
-
-    if (col.isOpaque ())
-        m_brushPixmap [colorsAreSwapped () ? 0 : 1].fill (col.toQColor ());
-
-    updateBrushCursor ();
-}
-
-// private slot
-void kpToolPen::slotBrushChanged (const QPixmap &pixmap, bool isDiagonalLine)
-{
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "kpToolPen::slotBrushChanged()" << endl;
-#endif
-    for (int i = 0; i < 2; i++)
-    {
-        m_brushPixmap [i] = pixmap;
-        if (color (i).isOpaque ())
-            m_brushPixmap [i].fill (color (i).toQColor ());
-    }
-
-    m_brushIsDiagonalLine = isDiagonalLine;
-
-    updateBrushCursor ();
-}
-
-// private slot
-void kpToolPen::slotEraserSizeChanged (int size)
-{
-#if DEBUG_KP_TOOL_PEN
-    kdDebug () << "KpToolPen::slotEraserSizeChanged(size=" << size << ")" << endl;
-#endif
-
-    for (int i = 0; i < 2; i++)
-    {
-        m_brushPixmap [i].resize (size, size);
-        if (color (i).isOpaque ())
-            m_brushPixmap [i].fill (color (i).toQColor ());
-    }
-
-    updateBrushCursor ();
-}
-
-QPoint kpToolPen::hotPoint () const
-{
-    return hotPoint (m_currentPoint);
-}
-
-QPoint kpToolPen::hotPoint (int x, int y) const
-{
-    return hotPoint (QPoint (x, y));
-}
-
-QPoint kpToolPen::hotPoint (const QPoint &point) const
-{
-    /*
-     * e.g.
-     *    Width 5:
-     *    0 1 2 3 4
-     *        ^
-     *        |
-     *      Center
-     */
-    return point -
-           QPoint (m_brushPixmap [m_mouseButton].width () / 2,
-                   m_brushPixmap [m_mouseButton].height () / 2);
-}
-
-QRect kpToolPen::hotRect () const
-{
-    return hotRect (m_currentPoint);
-}
-
-QRect kpToolPen::hotRect (int x, int y) const
-{
-    return hotRect (QPoint (x, y));
-}
-
-QRect kpToolPen::hotRect (const QPoint &point) const
-{
-    QPoint topLeft = hotPoint (point);
-    return QRect (topLeft.x (),
-                  topLeft.y (),
-                  m_brushPixmap [m_mouseButton].width (),
-                  m_brushPixmap [m_mouseButton].height ());
-}
-
-// private
-void kpToolPen::updateBrushCursor (bool recalc)
-{
-#if DEBUG_KP_TOOL_PEN && 1
-    kdDebug () << "kpToolPen::updateBrushCursor(recalc=" << recalc << ")" << endl;
-#endif
-
-    if (recalc)
-    {
-        if (haveSquareBrushes ())
-            m_cursorPixmap = m_toolWidgetEraserSize->cursorPixmap (color (0));
-        else if (haveDiverseBrushes ())
-            m_cursorPixmap = m_brushPixmap [0];
-    }
-
-    hover (hasBegun () ? m_currentPoint : currentPoint ());
-}
-
-
-//
-// kpToolPenCommand
-//
-
-kpToolPenCommand::kpToolPenCommand (const QString &name, kpMainWindow *mainWindow)
-    : kpNamedCommand (name, mainWindow),
-      m_pixmap (*document ()->pixmap ())
-{
-}
-
-kpToolPenCommand::~kpToolPenCommand ()
-{
-}
-
-
-// public virtual [base kpCommand]
-int kpToolPenCommand::size () const
-{
-    return kpPixmapFX::pixmapSize (m_pixmap);
-}
-
-
-// public virtual [base kpCommand]
-void kpToolPenCommand::execute ()
-{
-    swapOldAndNew ();
-}
-
-// public virtual [base kpCommand]
-void kpToolPenCommand::unexecute ()
-{
-    swapOldAndNew ();
-}
-
-
-// private
-void kpToolPenCommand::swapOldAndNew ()
-{
-    if (m_boundingRect.isValid ())
-    {
-        QPixmap oldPixmap = document ()->getPixmapAt (m_boundingRect);
-
-        document ()->setPixmapAt (m_pixmap, m_boundingRect.topLeft ());
-
-        m_pixmap = oldPixmap;
-    }
-}
-
-// public
-void kpToolPenCommand::updateBoundingRect (const QPoint &point)
-{
-    updateBoundingRect (QRect (point, point));
-}
-
-// public
-void kpToolPenCommand::updateBoundingRect (const QRect &rect)
-{
-#if DEBUG_KP_TOOL_PEN & 0
-    kdDebug () << "kpToolPenCommand::updateBoundingRect()  existing="
-               << m_boundingRect
-               << " plus="
-               << rect
-               << endl;
-#endif
-    m_boundingRect = m_boundingRect.unite (rect);
-#if DEBUG_KP_TOOL_PEN & 0
-    kdDebug () << "\tresult=" << m_boundingRect << endl;
-#endif
-}
-
-// public
-void kpToolPenCommand::finalize ()
-{
-    if (m_boundingRect.isValid ())
-    {
-        // store only needed part of doc pixmap
-        m_pixmap = kpTool::neededPixmap (m_pixmap, m_boundingRect);
-    }
-    else
-    {
-        m_pixmap.resize (0, 0);
-    }
-}
-
-// public
-void kpToolPenCommand::cancel ()
-{
-    if (m_boundingRect.isValid ())
-    {
-        viewManager ()->setFastUpdates ();
-        document ()->setPixmapAt (m_pixmap, m_boundingRect.topLeft ());
-        viewManager ()->restoreFastUpdates ();
-    }
-}
-
 #include <kptoolpen.moc>
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/kptoolpen.h head/kolourpaint/tools/kptoolpen.h
--- base/kolourpaint/tools/kptoolpen.h	2005-06-23 18:27:46.000000000 +1000
+++ head/kolourpaint/tools/kptoolpen.h	2005-06-23 19:07:25.704606200 +1000
@@ -26,149 +26,28 @@
 */
 
 
-#ifndef __kptoolpen_h__
-#define __kptoolpen_h__
+#ifndef KP_TOOL_PEN_H
+#define KP_TOOL_PEN_H
 
-#include <qpixmap.h>
-#include <qrect.h>
-#include <qvaluevector.h>
 
-#include <kpcommandhistory.h>
-#include <kptool.h>
-
-class QPoint;
-class QString;
+#include <kptoolflowbase.h>
 
-class kpColor;
-class kpMainWindow;
-class kpToolPenCommand;
-class kpToolWidgetBrush;
-class kpToolWidgetEraserSize;
-class kpViewManager;
 
-class kpToolPen : public kpTool
+// Pen = draws pixels, "interpolates" by "sweeping" pixels along a line (no brushes)
+class kpToolPen : public kpToolFlowBase
 {
 Q_OBJECT
 
 public:
-    enum Mode
-    {
-        // tool properties
-        DrawsPixels = (1 << 0), DrawsPixmaps = (1 << 1), WashesPixmaps = (1 << 2),
-        NoBrushes = 0, SquareBrushes = (1 << 3), DiverseBrushes = (1 << 4),
-        NormalColors = 0, SwappedColors = (1 << 5),
-
-        // tools:
-        //
-        // Pen = draws pixels, "interpolates" by "sweeping" pixels along a line (no brushes)
-        // Brush = draws pixmaps, "interpolates" by "sweeping" pixmaps along a line (interesting brushes)
-        // Eraser = Brush but with foreground & background colors swapped (a few square brushes)
-        // Color Washer = Brush that replaces/washes the foreground color with the background color
-        //
-        // (note the capitalization of "brush" here :))
-        Pen = DrawsPixels | NoBrushes | NormalColors,
-        Brush = DrawsPixmaps | DiverseBrushes | NormalColors,
-        Eraser = DrawsPixmaps | SquareBrushes | SwappedColors,
-        ColorWasher = WashesPixmaps | SquareBrushes | SwappedColors
-    };
-
-    kpToolPen (Mode mode, const QString &text, const QString &description,
-               int key,
-               kpMainWindow *mainWindow, const char *name);
     kpToolPen (kpMainWindow *mainWindow);
     virtual ~kpToolPen ();
 
-    void setMode (Mode mode);
-
 protected:
-    // TODO: all virtual without inline impl eventually abstract in pull-up
     virtual QString haventBegunDrawUserMessage () const;
-    virtual kpToolPenCommand *newCommand () const;
-    virtual bool haveSquareBrushes () const { return false; }
-    virtual bool haveDiverseBrushes () const { return false; }
-    virtual bool colorsAreSwapped () const { return false; }
-    bool haveAnyBrushes () const { return (haveSquareBrushes () || haveDiverseBrushes ()); }
-    
-public:
-    virtual void begin ();
-    virtual void end ();
-
-    virtual void beginDraw ();
-    virtual void hover (const QPoint &point);
-    
-    QValueVector <QPoint> interpolatePoints (const QRect &rect/*TODO:take me away*/,
-        const QPoint &thisPoint, const QPoint &lastPoint);
-
     virtual void drawPoint (const QPoint &point);
-    
-    void drawLineSetupPainterMask (QPixmap *pixmap,
-        QBitmap *maskBitmap,
-        QPainter *painter, QPainter *maskPainter);
-    void drawLineTearDownPainterMask (QPixmap *pixmap,
-        const QBitmap *maskBitmap,
-        QPainter *painter, QPainter *maskPainter);
-        
     virtual bool drawLine (QPixmap *pixmap, const QRect &docRect,
         const QPoint &thisPoint, const QPoint &lastPoint);
-
-    virtual bool drawShouldProceed (const QPoint & /*thisPoint*/, const QPoint & /*lastPoint*/, const QRect & /*normalizedRect*/) { return true; }
-    virtual void draw (const QPoint &thisPoint, const QPoint &lastPoint, const QRect &normalizedRect);
-    virtual void cancelShape ();
-    virtual void releasedAllButtons ();
-    virtual void endDraw (const QPoint &, const QRect &);
-
-protected slots:
-    virtual void slotForegroundColorChanged (const kpColor &col);
-    virtual void slotBackgroundColorChanged (const kpColor &col);
-
-    void slotBrushChanged (const QPixmap &pixmap, bool isDiagonalLine);
-    void slotEraserSizeChanged (int size);
-
-protected:
-    virtual kpColor color (int which);
-
-    QPoint hotPoint () const;
-    QPoint hotPoint (int x, int y) const;
-    QPoint hotPoint (const QPoint &point) const;
-    QRect hotRect () const;
-    QRect hotRect (int x, int y) const;
-    QRect hotRect (const QPoint &point) const;
-
-    Mode m_mode;
-
-    void updateBrushCursor (bool recalc = true);
-
-    kpToolWidgetBrush *m_toolWidgetBrush;
-    kpToolWidgetEraserSize *m_toolWidgetEraserSize;
-    QPixmap m_brushPixmap [2];
-    QPixmap m_cursorPixmap;
-    bool m_brushIsDiagonalLine;
-
-    kpToolPenCommand *m_currentCommand;
 };
 
-class kpToolPenCommand : public kpNamedCommand
-{
-public:
-    kpToolPenCommand (const QString &name, kpMainWindow *mainWindow);
-    virtual ~kpToolPenCommand ();
-
-    virtual int size () const;
-    
-    virtual void execute ();
-    virtual void unexecute ();
-
-    // interface for KToolPen
-    void updateBoundingRect (const QPoint &point);
-    void updateBoundingRect (const QRect &rect);
-    void finalize ();
-    void cancel ();
-
-private:
-    void swapOldAndNew ();
-
-    QPixmap m_pixmap;
-    QRect m_boundingRect;
-};
-
-#endif  // __kptoolpen_h__
+        
+#endif  // KP_TOOL_PEN_H
diff -Nudpr -x'*.o' -x'*.moc' -xconfig.log -x.deps -xkolourpaintlicense.h -x.libs -xMakefile.in -xMakefile -x'*~' -x'*.lo' -x'.*.sw*' -xk -xCODING_STYLE -xkolourpaintversion.h -xTODO -x'autom*' base/kolourpaint/tools/Makefile.am head/kolourpaint/tools/Makefile.am
--- base/kolourpaint/tools/Makefile.am	2005-06-23 18:27:46.921236240 +1000
+++ head/kolourpaint/tools/Makefile.am	2005-06-23 19:02:06.563123080 +1000
@@ -14,6 +14,8 @@ libkolourpainttools_la_SOURCES = kptool.
     kptoolconverttograyscale.cpp \
     kptoolcrop.cpp \
     kptoolcurve.cpp \
+    kptoolflowbase.cpp \
+    kptoolflowcommand.cpp \
     kptoolflowpixmapbase.cpp \
     kptoolellipse.cpp \
     kptoolellipticalselection.cpp kptooleraser.cpp \
@@ -37,11 +39,12 @@ METASOURCES = kptool.moc \
     kptoolcolorpicker.moc \
     kptoolcolorwasher.moc \
     kptoolcurve.moc \
-    kptoolflowpixmapbase.moc \
     kptoolellipse.moc \
     kptooleraser.moc \
     kptoolflip.moc \
     kptoolfloodfill.moc \
+    kptoolflowbase.moc \
+    kptoolflowpixmapbase.moc \
     kptoolline.moc \
     kptoolpen.moc \
     kptoolpolygon.moc \
